import {
  require_vue
} from "./chunk-IE7WQOHM.js";
import "./chunk-JZ5MYNVO.js";
import "./chunk-BRKTSBCT.js";
import {
  __commonJS,
  __esm,
  __export
} from "./chunk-4RZOBD6K.js";

// node_modules/lodash.get/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.get/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol = root.Symbol;
    var splice = arrayProto.splice;
    var Map = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray = Array.isArray;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get;
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/lodash.map/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.map/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module.exports = map;
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep;
  }
});

// node_modules/lodash.intersection/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.intersection/index.js"(exports, module) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var splice = arrayProto.splice;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var Map = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : void 0;
      }
      array = arrays[0];
      var index = -1, seen = caches[0];
      outer:
        while (++index < length && result.length < maxLength) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
              var cache = caches[othIndex];
              if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
    });
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module.exports = intersection;
  }
});

// node_modules/body-scroll-lock/lib/bodyScrollLock.esm.js
var bodyScrollLock_esm_exports = {};
__export(bodyScrollLock_esm_exports, {
  clearAllBodyScrollLocks: () => clearAllBodyScrollLocks,
  disableBodyScroll: () => disableBodyScroll,
  enableBodyScroll: () => enableBodyScroll
});
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var hasPassiveEvents, passiveTestOptions, isIosDevice, locks, documentListenerAdded, initialClientY, previousBodyOverflowSetting, previousBodyPaddingRight, allowTouchMove, preventDefault, setOverflowHidden, restoreOverflowSetting, isTargetElementTotallyScrolled, handleScroll, disableBodyScroll, clearAllBodyScrollLocks, enableBodyScroll;
var init_bodyScrollLock_esm = __esm({
  "node_modules/body-scroll-lock/lib/bodyScrollLock.esm.js"() {
    hasPassiveEvents = false;
    if (typeof window !== "undefined") {
      passiveTestOptions = {
        get passive() {
          hasPassiveEvents = true;
          return void 0;
        }
      };
      window.addEventListener("testPassive", null, passiveTestOptions);
      window.removeEventListener("testPassive", null, passiveTestOptions);
    }
    isIosDevice = typeof window !== "undefined" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
    locks = [];
    documentListenerAdded = false;
    initialClientY = -1;
    previousBodyOverflowSetting = void 0;
    previousBodyPaddingRight = void 0;
    allowTouchMove = function allowTouchMove2(el) {
      return locks.some(function(lock) {
        if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {
          return true;
        }
        return false;
      });
    };
    preventDefault = function preventDefault2(rawEvent) {
      var e = rawEvent || window.event;
      if (allowTouchMove(e.target)) {
        return true;
      }
      if (e.touches.length > 1)
        return true;
      if (e.preventDefault)
        e.preventDefault();
      return false;
    };
    setOverflowHidden = function setOverflowHidden2(options) {
      if (previousBodyPaddingRight === void 0) {
        var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;
        var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;
        if (_reserveScrollBarGap && scrollBarGap > 0) {
          previousBodyPaddingRight = document.body.style.paddingRight;
          document.body.style.paddingRight = scrollBarGap + "px";
        }
      }
      if (previousBodyOverflowSetting === void 0) {
        previousBodyOverflowSetting = document.body.style.overflow;
        document.body.style.overflow = "hidden";
      }
    };
    restoreOverflowSetting = function restoreOverflowSetting2() {
      if (previousBodyPaddingRight !== void 0) {
        document.body.style.paddingRight = previousBodyPaddingRight;
        previousBodyPaddingRight = void 0;
      }
      if (previousBodyOverflowSetting !== void 0) {
        document.body.style.overflow = previousBodyOverflowSetting;
        previousBodyOverflowSetting = void 0;
      }
    };
    isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled2(targetElement) {
      return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;
    };
    handleScroll = function handleScroll2(event, targetElement) {
      var clientY = event.targetTouches[0].clientY - initialClientY;
      if (allowTouchMove(event.target)) {
        return false;
      }
      if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {
        return preventDefault(event);
      }
      if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {
        return preventDefault(event);
      }
      event.stopPropagation();
      return true;
    };
    disableBodyScroll = function disableBodyScroll2(targetElement, options) {
      if (!targetElement) {
        console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
        return;
      }
      if (locks.some(function(lock2) {
        return lock2.targetElement === targetElement;
      })) {
        return;
      }
      var lock = {
        targetElement,
        options: options || {}
      };
      locks = [].concat(_toConsumableArray(locks), [lock]);
      if (isIosDevice) {
        targetElement.ontouchstart = function(event) {
          if (event.targetTouches.length === 1) {
            initialClientY = event.targetTouches[0].clientY;
          }
        };
        targetElement.ontouchmove = function(event) {
          if (event.targetTouches.length === 1) {
            handleScroll(event, targetElement);
          }
        };
        if (!documentListenerAdded) {
          document.addEventListener("touchmove", preventDefault, hasPassiveEvents ? { passive: false } : void 0);
          documentListenerAdded = true;
        }
      } else {
        setOverflowHidden(options);
      }
    };
    clearAllBodyScrollLocks = function clearAllBodyScrollLocks2() {
      if (isIosDevice) {
        locks.forEach(function(lock) {
          lock.targetElement.ontouchstart = null;
          lock.targetElement.ontouchmove = null;
        });
        if (documentListenerAdded) {
          document.removeEventListener("touchmove", preventDefault, hasPassiveEvents ? { passive: false } : void 0);
          documentListenerAdded = false;
        }
        initialClientY = -1;
      } else {
        restoreOverflowSetting();
      }
      locks = [];
    };
    enableBodyScroll = function enableBodyScroll2(targetElement) {
      if (!targetElement) {
        console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");
        return;
      }
      locks = locks.filter(function(lock) {
        return lock.targetElement !== targetElement;
      });
      if (isIosDevice) {
        targetElement.ontouchstart = null;
        targetElement.ontouchmove = null;
        if (documentListenerAdded && locks.length === 0) {
          document.removeEventListener("touchmove", preventDefault, hasPassiveEvents ? { passive: false } : void 0);
          documentListenerAdded = false;
        }
      } else if (!locks.length) {
        restoreOverflowSetting();
      }
    };
  }
});

// node_modules/lodash.range/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.range/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeCeil = Math.ceil;
    var nativeMax = Math.max;
    function baseRange(start, end, step, fromRight) {
      var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
          end = step = void 0;
        }
        start = toFinite(start);
        if (end === void 0) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    var range = createRange();
    module.exports = range;
  }
});

// node_modules/lodash.kebabcase/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.kebabcase/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol = root.Symbol;
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? "-" : "") + word.toLowerCase();
    });
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module.exports = kebabCase;
  }
});

// node_modules/lodash.pick/index.js
var require_lodash8 = __commonJS({
  "node_modules/lodash.pick/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var Symbol = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : void 0;
    var nativeMax = Math.max;
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function basePick(object, props) {
      object = Object(object);
      return basePickBy(object, props, function(value, key) {
        return key in object;
      });
    }
    function basePickBy(object, props, predicate) {
      var index = -1, length = props.length, result = {};
      while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var pick = baseRest(function(object, props) {
      return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
    });
    module.exports = pick;
  }
});

// node_modules/lodash.merge/index.js
var require_lodash9 = __commonJS({
  "node_modules/lodash.merge/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge;
  }
});

// node_modules/vue-tailwind/dist/components.js
var require_components = __commonJS({
  "node_modules/vue-tailwind/dist/components.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_vue(), require_lodash(), require_lodash2(), require_lodash3(), require_lodash4(), require_lodash5(), (init_bodyScrollLock_esm(), bodyScrollLock_esm_exports), require_lodash6(), require_lodash7(), require_lodash8(), require_lodash9()) : typeof define === "function" && define.amd ? define(["exports", "vue", "lodash.get", "lodash.isequal", "lodash.map", "lodash.clonedeep", "lodash.intersection", "body-scroll-lock", "lodash.range", "lodash.kebabcase", "lodash.pick", "lodash.merge"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.VueTailwind = {}, global2.Vue, global2.get, global2.isEqual, global2.map, global2.cloneDeep, global2.intersection, global2.bodyScrollLock, global2.range, global2.kebabCase, global2.pick, global2.merge));
    })(exports, function(exports2, Vue, get, isEqual, map, cloneDeep, intersection, bodyScrollLock, range, kebabCase, pick, merge) {
      "use strict";
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var Vue__default = _interopDefaultLegacy(Vue);
      var get__default = _interopDefaultLegacy(get);
      var isEqual__default = _interopDefaultLegacy(isEqual);
      var map__default = _interopDefaultLegacy(map);
      var cloneDeep__default = _interopDefaultLegacy(cloneDeep);
      var intersection__default = _interopDefaultLegacy(intersection);
      var range__default = _interopDefaultLegacy(range);
      var kebabCase__default = _interopDefaultLegacy(kebabCase);
      var pick__default = _interopDefaultLegacy(pick);
      var merge__default = _interopDefaultLegacy(merge);
      const mergeClasses = (classesA, classesB) => {
        let a = classesA;
        let b = classesB;
        if (Array.isArray(classesA) && classesA.every((className) => typeof className === "string" || !!className)) {
          a = classesA.filter((className) => !!className).join(" ");
        }
        if (Array.isArray(classesB) && classesB.every((className) => typeof className === "string" || !!className)) {
          b = classesB.filter((className) => !!className).join(" ");
        }
        if (typeof a === "string" && typeof b === "string") {
          return `${a} ${b}`;
        }
        if (typeof a === "string" && Array.isArray(b)) {
          return [a].concat(b);
        }
        if (typeof b === "string" && Array.isArray(a)) {
          return a.concat([b]);
        }
        if (Array.isArray(a) && Array.isArray(b)) {
          return a.concat(b);
        }
        return [a, b];
      };
      const Component = Vue__default["default"].extend({
        props: {
          classes: {
            type: [String, Array, Object],
            default: void 0
          },
          fixedClasses: {
            type: [String, Array, Object],
            default: void 0
          },
          variants: {
            type: Object,
            default: void 0
          },
          variant: {
            type: [String, Object],
            default: void 0
          }
        },
        computed: {
          componentClass() {
            return this.getElementCssClass();
          },
          activeVariant() {
            if (!this.variant) {
              return void 0;
            }
            if (typeof this.variant === "object") {
              const truthyVariant = Object.keys(this.variant).find((variant) => !!this.variant[variant]);
              return truthyVariant || void 0;
            }
            return this.variant;
          }
        },
        methods: {
          getElementCssClass(elementName, defaultClasses = "") {
            let classes;
            if (elementName) {
              if (this.activeVariant) {
                const elementVariant = get__default["default"](this.variants, `${this.activeVariant}.${elementName}`);
                if (elementVariant === void 0 && get__default["default"](this.variants, this.activeVariant) !== void 0) {
                  classes = get__default["default"](this.classes, elementName, defaultClasses);
                } else {
                  classes = elementVariant === void 0 ? defaultClasses : elementVariant;
                }
              } else {
                classes = get__default["default"](this.classes, elementName, defaultClasses);
              }
              const fixedClasses = get__default["default"](this.fixedClasses, elementName);
              if (fixedClasses) {
                return mergeClasses(fixedClasses, classes);
              }
              return classes;
            }
            if (this.activeVariant) {
              classes = get__default["default"](this.variants, this.activeVariant, defaultClasses);
            } else {
              classes = this.classes === void 0 ? defaultClasses : this.classes;
            }
            if (this.fixedClasses) {
              return mergeClasses(this.fixedClasses, classes);
            }
            return classes;
          }
        }
      });
      const HtmlInput = Component.extend({
        props: {
          id: {
            type: String,
            default: void 0
          },
          name: {
            type: String,
            default: void 0
          },
          disabled: {
            type: Boolean,
            default: void 0
          },
          readonly: {
            type: Boolean,
            default: void 0
          },
          autofocus: {
            type: Boolean,
            default: void 0
          },
          required: {
            type: Boolean,
            default: void 0
          },
          tabindex: {
            type: [String, Number],
            default: void 0
          }
        },
        methods: {
          getListeners(listeners) {
            return Object.assign(Object.assign({}, this.$listeners), listeners);
          }
        }
      });
      var Key;
      (function(Key2) {
        Key2[Key2["LEFT"] = 37] = "LEFT";
        Key2[Key2["UP"] = 38] = "UP";
        Key2[Key2["RIGHT"] = 39] = "RIGHT";
        Key2[Key2["DOWN"] = 40] = "DOWN";
        Key2[Key2["ENTER"] = 13] = "ENTER";
        Key2[Key2["ESC"] = 27] = "ESC";
        Key2[Key2["SPACE"] = 32] = "SPACE";
        Key2[Key2["BACKSPACE"] = 8] = "BACKSPACE";
      })(Key || (Key = {}));
      var Key$1 = Key;
      const TCheckbox = HtmlInput.extend({
        name: "TCheckbox",
        props: {
          value: {
            type: [String, Object, Number, Boolean, Array],
            default: true
          },
          uncheckedValue: {
            type: [String, Object, Number, Boolean, Array],
            default: false
          },
          indeterminate: {
            type: [Boolean, String],
            default: void 0
          },
          checked: {
            type: [Boolean, String],
            default: void 0
          },
          model: {
            type: [String, Object, Number, Boolean, Array],
            default: void 0
          },
          wrapped: {
            type: Boolean,
            default: false
          },
          wrapperTag: {
            type: String,
            default: "label"
          },
          inputWrapperTag: {
            type: String,
            default: "span"
          },
          labelTag: {
            type: String,
            default: "span"
          },
          label: {
            type: [String, Number],
            default: void 0
          },
          classes: {
            type: [String, Array, Object],
            default: "text-blue-500 transition duration-100 ease-in-out border-gray-300 rounded shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 focus:ring-offset-0 disabled:opacity-50 disabled:cursor-not-allowed"
          }
        },
        data() {
          return {
            localValue: this.model
          };
        },
        model: {
          prop: "model",
          event: "input"
        },
        render(createElement) {
          const renderFun = this.render;
          const createWrappedFunc = this.renderWrapped;
          if (this.wrapped) {
            return createWrappedFunc(createElement);
          }
          return renderFun(createElement);
        },
        computed: {
          isChecked: {
            get() {
              if (this.model === void 0) {
                return this.checked;
              }
              if (Array.isArray(this.model)) {
                return this.model.indexOf(this.value) >= 0;
              }
              return this.model === this.value;
            },
            set(checked) {
              this.localValue = checked;
            }
          }
        },
        watch: {
          isChecked(isChecked2) {
            const input = this.getInput();
            if (input.checked !== isChecked2) {
              input.checked = isChecked2;
            }
          },
          indeterminate(indeterminate) {
            this.setIndeterminate(indeterminate);
          },
          checked(checked) {
            this.setChecked(checked);
          }
        },
        methods: {
          getInput() {
            return this.$refs.input;
          },
          renderWrapped(createElement) {
            const childElements = [];
            const input = this.render(createElement);
            const inputWrapperClass = this.getElementCssClass("inputWrapper");
            const checkedInputWrapperClass = this.getElementCssClass("inputWrapperChecked", this.getElementCssClass("inputWrapper"));
            childElements.push(createElement(this.inputWrapperTag, {
              ref: "inputWrapper",
              class: this.isChecked ? checkedInputWrapperClass : inputWrapperClass
            }, [
              input
            ]));
            const labelClass = this.getElementCssClass("label");
            const checkedLabelClass = this.getElementCssClass("labelChecked", this.getElementCssClass("label"));
            let label;
            if (this.$scopedSlots.default !== void 0) {
              label = this.$scopedSlots.default({
                isChecked: this.isChecked,
                value: this.isChecked ? this.value : this.uncheckedValue,
                label: this.label
              });
            } else {
              label = typeof this.label === "number" ? String(this.label) : this.label;
            }
            childElements.push(createElement(this.labelTag, {
              ref: "label",
              class: this.isChecked ? checkedLabelClass : labelClass
            }, label));
            const wrapperClass = this.getElementCssClass("wrapper");
            const checkedWrapperClass = this.getElementCssClass("wrapperChecked", this.getElementCssClass("wrapper"));
            return createElement(this.wrapperTag, {
              ref: "wrapper",
              class: this.isChecked ? checkedWrapperClass : wrapperClass,
              attrs: {
                for: this.id,
                tabindex: this.tabindex,
                autofocus: this.autofocus
              },
              on: {
                keydown: (e) => {
                  if (e.keyCode === Key$1.SPACE) {
                    this.wrapperSpaceHandler(e);
                  }
                }
              }
            }, childElements);
          },
          render(createElement) {
            return createElement("input", {
              class: this.wrapped ? this.getElementCssClass("input") : this.componentClass,
              ref: "input",
              attrs: {
                checked: this.isChecked,
                value: this.value,
                id: this.id,
                type: "checkbox",
                name: this.name,
                disabled: this.disabled,
                readonly: this.readonly,
                required: this.required,
                autofocus: !this.wrapped ? this.autofocus : void 0,
                tabindex: this.wrapped && this.tabindex !== void 0 ? -1 : this.tabindex
              },
              on: this.getListeners({
                blur: this.blurHandler,
                focus: this.focusHandler,
                change: this.changeHandler,
                input: () => {
                }
              })
            });
          },
          wrapperSpaceHandler(e) {
            e.preventDefault();
            this.click();
          },
          setIndeterminate(indeterminate) {
            const input = this.getInput();
            input.indeterminate = indeterminate;
            this.$emit("update:indeterminate", indeterminate);
          },
          setChecked(checked) {
            const input = this.getInput();
            input.checked = !checked;
            input.click();
            this.$emit("update:checked", checked);
          },
          changeHandler() {
            const input = this.getInput();
            const isChecked2 = input.checked;
            let localValue;
            if (Array.isArray(this.model)) {
              localValue = [...this.model];
              const index = localValue.indexOf(this.value);
              if (isChecked2 && index < 0) {
                localValue.push(this.value);
              } else if (!isChecked2 && index >= 0) {
                localValue.splice(index, 1);
              }
            } else {
              localValue = isChecked2 ? this.value : this.uncheckedValue;
            }
            this.$emit("input", localValue);
            this.$emit("change", localValue);
            this.$emit("update:indeterminate", false);
            this.$emit("update:checked", isChecked2);
          },
          blurHandler(e) {
            this.$emit("blur", e);
          },
          focusHandler(e) {
            this.$emit("focus", e);
          },
          blur() {
            this.getInput().blur();
          },
          click() {
            this.getInput().click();
          },
          focus(options) {
            this.getInput().focus(options);
          }
        }
      });
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      const checkIfTagShouldBeChecked = (model, checked, value) => model === void 0 ? !!checked : isEqual__default["default"](model, value);
      const TRadio = HtmlInput.extend({
        name: "TRadio",
        props: {
          value: {
            type: [String, Object, Number, Boolean, Array],
            default: "on"
          },
          checked: {
            type: [Boolean, String],
            default: false
          },
          model: {
            type: [String, Object, Number, Boolean, Array],
            default: void 0
          },
          wrapped: {
            type: Boolean,
            default: false
          },
          wrapperTag: {
            type: String,
            default: "label"
          },
          inputWrapperTag: {
            type: String,
            default: "span"
          },
          labelTag: {
            type: String,
            default: "span"
          },
          label: {
            type: [String, Number],
            default: void 0
          },
          classes: {
            type: [String, Array, Object],
            default: "text-blue-500 transition duration-100 ease-in-out border-gray-300 shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 focus:ring-offset-0  disabled:opacity-50 disabled:cursor-not-allowed"
          }
        },
        data() {
          return {
            localValue: this.checked ? this.value : null
          };
        },
        model: {
          prop: "model",
          event: "input"
        },
        render(createElement) {
          const renderFun = this.render;
          const createWrappedFunc = this.renderWrapped;
          if (this.wrapped) {
            return createWrappedFunc(createElement);
          }
          return renderFun(createElement);
        },
        watch: {
          model(model) {
            if (isEqual__default["default"](model, this.localValue)) {
              return;
            }
            this.localValue = model;
          },
          checked(checked) {
            const localValue = checked ? this.value : null;
            if (!isEqual__default["default"](localValue, this.localValue)) {
              this.localValue = localValue;
            }
          },
          localValue(localValue) {
            if (isEqual__default["default"](this.model, localValue)) {
              return;
            }
            this.$emit("input", localValue);
            this.$emit("change", localValue);
          },
          isChecked(isChecked2) {
            const input = this.$refs.input;
            if (input && input.checked !== isChecked2) {
              input.checked = isChecked2;
            }
          }
        },
        computed: {
          isChecked() {
            return checkIfTagShouldBeChecked(this.model, this.checked, this.value);
          }
        },
        methods: {
          renderWrapped(createElement) {
            const childElements = [];
            const input = this.render(createElement);
            const inputWrapperClass = this.getElementCssClass("inputWrapper");
            const checkedInputWrapperClass = this.getElementCssClass("inputWrapperChecked", this.getElementCssClass("inputWrapper"));
            childElements.push(createElement(this.inputWrapperTag, {
              ref: "inputWrapper",
              class: this.isChecked ? checkedInputWrapperClass : inputWrapperClass
            }, [
              input
            ]));
            const labelClass = this.getElementCssClass("label");
            const checkedLabelClass = this.getElementCssClass("labelChecked", this.getElementCssClass("label"));
            let label;
            if (this.$scopedSlots.default !== void 0) {
              label = this.$scopedSlots.default({
                isChecked: this.isChecked,
                value: this.localValue,
                label: this.label
              });
            } else {
              label = typeof this.label === "number" ? String(this.label) : this.label;
            }
            childElements.push(createElement(this.labelTag, {
              ref: "label",
              class: this.isChecked ? checkedLabelClass : labelClass
            }, label));
            const wrapperClass = this.getElementCssClass("wrapper");
            const checkedWrapperClass = this.getElementCssClass("wrapperChecked", this.getElementCssClass("wrapper"));
            return createElement(this.wrapperTag, {
              ref: "wrapper",
              class: this.isChecked ? checkedWrapperClass : wrapperClass,
              attrs: {
                for: this.id,
                tabindex: this.tabindex,
                autofocus: this.autofocus
              },
              on: {
                keydown: (e) => {
                  if ([Key$1.DOWN, Key$1.RIGHT].includes(e.keyCode)) {
                    this.selectNextRadio(e);
                  } else if ([Key$1.UP, Key$1.LEFT].includes(e.keyCode)) {
                    this.selectPrevRadio(e);
                  } else if (e.keyCode === Key$1.SPACE) {
                    this.wrapperSpaceHandler(e);
                  }
                }
              }
            }, childElements);
          },
          render(createElement) {
            return createElement("input", {
              class: this.wrapped ? this.getElementCssClass("input") : this.componentClass,
              ref: "input",
              attrs: {
                value: this.value,
                id: this.id,
                type: "radio",
                checked: checkIfTagShouldBeChecked(this.model, this.checked, this.value),
                name: this.name,
                disabled: this.disabled,
                readonly: this.readonly,
                required: this.required,
                autofocus: !this.wrapped ? this.autofocus : void 0,
                tabindex: this.wrapped && this.tabindex !== void 0 ? -1 : this.tabindex
              },
              on: this.getListeners({
                blur: this.blurHandler,
                focus: this.focusHandler,
                input: this.inputHandler
              })
            });
          },
          inputHandler(e) {
            return __awaiter(this, void 0, void 0, function* () {
              const target = e.target;
              if (target.checked) {
                this.localValue = this.value;
                this.sendInputEventToTheNotCheckedInputs();
              }
            });
          },
          sendInputEventToTheNotCheckedInputs() {
            const notCheckedEls = document.querySelectorAll(`input[name=${this.name}]:not(:checked)`);
            notCheckedEls.forEach((el) => {
              el.dispatchEvent(new Event("input"));
            });
          },
          selectPrevRadio(e) {
            e.preventDefault();
            const currentEl = this.$refs.input;
            const els = Array.from(document.querySelectorAll(`input[name=${this.name}]`));
            const currentElementIndex = els.findIndex((radioInput) => radioInput === this.$refs.input);
            const prevElement = els[currentElementIndex - 1] || els[els.length - 1];
            if (prevElement !== currentEl && prevElement) {
              const wrapper = prevElement.parentNode ? prevElement.parentNode.parentNode : void 0;
              if (wrapper && wrapper.tabIndex >= 0) {
                wrapper.focus();
              } else {
                prevElement.focus();
              }
            }
          },
          selectNextRadio(e) {
            e.preventDefault();
            const currentEl = this.$refs.input;
            const els = Array.from(document.querySelectorAll(`input[name=${this.name}]`));
            const currentElementIndex = els.findIndex((radioInput) => radioInput === this.$refs.input);
            const nextElement = els[currentElementIndex + 1] || els[0];
            if (nextElement !== currentEl && nextElement) {
              const wrapper = nextElement.parentNode ? nextElement.parentNode.parentNode : void 0;
              if (wrapper && wrapper.tabIndex >= 0) {
                wrapper.focus();
              } else {
                nextElement.focus();
              }
            }
          },
          wrapperSpaceHandler(e) {
            e.preventDefault();
            this.localValue = this.value;
          },
          blurHandler(e) {
            this.$emit("blur", e);
          },
          focusHandler(e) {
            this.$emit("focus", e);
          },
          blur() {
            this.$refs.input.blur();
          },
          click() {
            this.$refs.input.click();
          },
          focus(options) {
            this.$refs.input.focus(options);
          }
        }
      });
      const TextInput = HtmlInput.extend({
        props: {
          value: {
            type: [String, Number],
            default: void 0
          },
          autocomplete: {
            type: String,
            default: void 0
          },
          maxlength: {
            type: [String, Number],
            default: void 0
          },
          minlength: {
            type: [String, Number],
            default: void 0
          },
          multiple: {
            type: Boolean,
            default: void 0
          },
          pattern: {
            type: String,
            default: void 0
          },
          placeholder: {
            type: String,
            default: void 0
          },
          classes: {
            type: [String, Array, Object],
            default: void 0
          }
        },
        data() {
          return {
            localValue: this.value,
            valueWhenFocus: null
          };
        },
        watch: {
          localValue(localValue) {
            this.$emit("input", localValue);
          },
          value(value) {
            this.localValue = value;
          }
        },
        methods: {
          blurHandler(e) {
            this.$emit("blur", e);
            if (this.localValue !== this.valueWhenFocus) {
              this.$emit("change", this.localValue);
            }
          },
          focusHandler(e) {
            this.$emit("focus", e);
            this.valueWhenFocus = this.localValue;
          },
          keyupHandler(e) {
            this.$emit("keyup", e);
          },
          keydownHandler(e) {
            this.$emit("keydown", e);
          },
          blur() {
            this.$el.blur();
          },
          click() {
            this.$el.click();
          },
          focus(options) {
            this.$el.focus(options);
          },
          select() {
            this.$el.select();
          },
          setSelectionRange(start, end, direction) {
            this.$el.setSelectionRange(start, end, direction);
          },
          setRangeText(replacement) {
            this.$el.setRangeText(replacement);
          }
        }
      });
      const TTextarea = TextInput.extend({
        name: "TTextarea",
        props: {
          rows: {
            type: String,
            default: void 0
          },
          cols: {
            type: String,
            default: void 0
          },
          wrap: {
            type: String,
            default: "soft"
          },
          classes: {
            type: [String, Array, Object],
            default: "block w-full px-3 py-2 text-black placeholder-gray-400 transition duration-100 ease-in-out bg-white border border-gray-300 rounded shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50  disabled:opacity-50 disabled:cursor-not-allowed"
          }
        },
        render(createElement) {
          const renderFun = this.render;
          return renderFun(createElement);
        },
        methods: {
          render(createElement) {
            return createElement("textarea", {
              class: this.componentClass,
              ref: "input",
              domProps: {
                value: this.localValue
              },
              attrs: {
                id: this.id,
                name: this.name,
                disabled: this.disabled,
                readonly: this.readonly,
                autocomplete: this.autocomplete,
                autofocus: this.autofocus,
                required: this.required,
                placeholder: this.placeholder,
                pattern: this.pattern,
                multiple: this.multiple,
                minlength: this.minlength,
                maxlength: this.maxlength,
                wrap: this.wrap,
                rows: this.rows,
                cols: this.cols
              },
              on: this.getListeners({
                blur: this.blurHandler,
                focus: this.focusHandler,
                keyup: this.keyupHandler,
                keydown: this.keydownHandler,
                input: this.inputHandler
              })
            });
          },
          inputHandler(e) {
            const target = e.target;
            this.$emit("input", target.value);
          }
        }
      });
      const TInput = TextInput.extend({
        name: "TInput",
        props: {
          type: {
            type: String,
            default: "text"
          },
          max: {
            type: [String, Number],
            default: void 0
          },
          min: {
            type: [String, Number],
            default: void 0
          },
          classes: {
            type: [String, Array, Object],
            default: "block w-full px-3 py-2 text-black placeholder-gray-400 transition duration-100 ease-in-out bg-white border border-gray-300 rounded shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed"
          }
        },
        render(createElement) {
          const renderFun = this.render;
          return renderFun(createElement);
        },
        methods: {
          render(createElement) {
            return createElement("input", {
              class: this.componentClass,
              ref: "input",
              domProps: {
                value: this.localValue
              },
              attrs: {
                id: this.id,
                name: this.name,
                disabled: this.disabled,
                readonly: this.readonly,
                autocomplete: this.autocomplete,
                autofocus: this.autofocus,
                type: this.type,
                required: this.required,
                placeholder: this.placeholder,
                pattern: this.pattern,
                multiple: this.multiple,
                minlength: this.minlength,
                min: this.min,
                maxlength: this.maxlength,
                max: this.max
              },
              on: this.getListeners({
                blur: this.blurHandler,
                focus: this.focusHandler,
                keyup: this.keyupHandler,
                keydown: this.keydownHandler,
                input: this.inputHandler
              })
            });
          },
          inputHandler(e) {
            const target = e.target;
            this.$emit("input", target.value);
          }
        }
      });
      const guessOptionValue = (option, valueAttribute) => {
        if (valueAttribute) {
          return get__default["default"](option, valueAttribute);
        }
        return get__default["default"](option, "value", get__default["default"](option, "id", get__default["default"](option, "text")));
      };
      const guessOptionText = (option, textAttribute) => {
        if (textAttribute) {
          return get__default["default"](option, textAttribute);
        }
        return get__default["default"](option, "text", get__default["default"](option, "label"));
      };
      const normalizeOption = (option, textAttribute, valueAttribute) => {
        if (typeof option === "string" || typeof option === "number" || typeof option === "boolean") {
          return {
            value: option,
            text: option,
            raw: option
          };
        }
        if (option.children) {
          const children = option.children.map((childOption) => normalizeOption(childOption));
          return {
            value: guessOptionValue(option, valueAttribute),
            text: guessOptionText(option, textAttribute),
            children
          };
        }
        const normalizedOption = {
          value: guessOptionValue(option, valueAttribute),
          text: guessOptionText(option, textAttribute),
          raw: option
        };
        if (option.disabled !== void 0) {
          normalizedOption.disabled = option.disabled;
        }
        return normalizedOption;
      };
      const normalizeOptions = (options, textAttribute, valueAttribute) => {
        if (!options) {
          return [];
        }
        if (Array.isArray(options)) {
          return options.map((option) => normalizeOption(option, textAttribute, valueAttribute));
        }
        return map__default["default"](options, (option, key) => ({
          value: key,
          text: option
        }));
      };
      const InputWithOptions = HtmlInput.extend({
        props: {
          value: {
            type: [String, Object, Number, Boolean],
            default: null
          },
          valueAttribute: {
            type: String,
            default: void 0
          },
          textAttribute: {
            type: String,
            default: void 0
          },
          options: {
            type: [Array, Object],
            default: void 0
          }
        },
        data() {
          return {
            localValue: this.value
          };
        },
        computed: {
          normalizedOptions() {
            return this.normalizeOptions(this.options);
          },
          flattenedOptions() {
            return this.normalizedOptions.map((option) => {
              if (option.children) {
                return option.children;
              }
              return option;
            }).flat();
          }
        },
        methods: {
          normalizeOptions(options) {
            return normalizeOptions(options, this.textAttribute, this.valueAttribute);
          }
        }
      });
      const MultipleInput = InputWithOptions.extend({
        props: {
          value: {
            type: [Array, String, Number, Boolean, Object],
            default: null
          },
          multiple: {
            type: Boolean,
            default: void 0
          }
        }
      });
      const TSelect = MultipleInput.extend({
        name: "TSelect",
        props: {
          placeholder: {
            type: String,
            default: void 0
          },
          wrapped: {
            type: Boolean,
            default: false
          },
          classes: {
            type: [String, Array, Object],
            default: "block w-full pl-3 pr-10 py-2 text-black placeholder-gray-400 transition duration-100 ease-in-out bg-white border border-gray-300 rounded shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed"
          }
        },
        data() {
          return {
            localValue: this.value
          };
        },
        computed: {
          normalizedOptionsWithPlaceholder() {
            if (this.placeholder === void 0) {
              return this.normalizedOptions;
            }
            const { normalizedOptions } = this;
            const placeholder = [{
              value: null,
              text: this.placeholder
            }];
            return placeholder.concat(normalizedOptions);
          }
        },
        watch: {
          localValue(localValue) {
            return __awaiter(this, void 0, void 0, function* () {
              this.$emit("input", localValue);
              yield this.$nextTick();
              this.$emit("change", localValue);
            });
          },
          value(value) {
            this.localValue = value;
          }
        },
        render(createElement) {
          const createSelectFunc = this.createSelect;
          const createSelectWrapperFunc = this.createSelectWrapper;
          if (this.wrapped) {
            return createSelectWrapperFunc(createElement);
          }
          return createSelectFunc(createElement);
        },
        methods: {
          createSelectWrapper(createElement) {
            const children = [
              this.createSelect(createElement)
            ];
            if (!this.multiple) {
              if (this.$scopedSlots.arrowWrapper) {
                const arrowWrapper = this.$scopedSlots.arrowWrapper({
                  className: this.getElementCssClass("arrowWrapper"),
                  variant: this.variant,
                  value: this.localValue
                });
                children.push(arrowWrapper);
              } else {
                children.push(this.createArrow(createElement));
              }
            }
            return createElement("div", {
              ref: "selectWrapper",
              class: this.getElementCssClass("wrapper")
            }, children);
          },
          createArrow(createElement) {
            const subElements = [];
            if (this.$scopedSlots.arrow) {
              subElements.push(this.$scopedSlots.arrow({
                className: this.getElementCssClass("arrow"),
                variant: this.variant,
                value: this.localValue
              }));
            } else {
              subElements.push(createElement("svg", {
                attrs: {
                  fill: "currentColor",
                  xmlns: "http://www.w3.org/2000/svg",
                  viewBox: "0 0 20 20"
                },
                class: this.getElementCssClass("arrow")
              }, [
                createElement("path", {
                  attrs: {
                    "clip-rule": "evenodd",
                    "fill-rule": "evenodd",
                    d: "M10 3a1 1 0 01.707.293l3 3a1 1 0 01-1.414 1.414L10 5.414 7.707 7.707a1 1 0 01-1.414-1.414l3-3A1 1 0 0110 3zm-3.707 9.293a1 1 0 011.414 0L10 14.586l2.293-2.293a1 1 0 011.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z"
                  }
                })
              ]));
            }
            return createElement("span", {
              ref: "arrow",
              class: this.getElementCssClass("arrowWrapper")
            }, subElements);
          },
          createSelect(createElement) {
            return createElement("select", {
              ref: "select",
              attrs: {
                id: this.id,
                autofocus: this.autofocus,
                disabled: this.disabled,
                name: this.name,
                required: this.required,
                multiple: this.multiple
              },
              class: this.wrapped ? this.getElementCssClass("input") : this.getElementCssClass(),
              on: this.getListeners({
                blur: this.blurHandler,
                focus: this.focusHandler,
                input: this.inputHandler
              })
            }, this.createOptions(createElement, this.value));
          },
          createOptions(createElement, value) {
            const options = this.normalizedOptionsWithPlaceholder;
            return options.map((option) => {
              if (option.children) {
                return this.createOptgroup(createElement, option, value);
              }
              return this.createOption(createElement, option, value);
            });
          },
          createOptgroup(createElement, option, value) {
            var _a;
            return createElement("optgroup", {
              domProps: {
                label: guessOptionText(option, this.textAttribute)
              }
            }, (_a = option.children) === null || _a === void 0 ? void 0 : _a.map((opt) => this.createOption(createElement, opt, value)));
          },
          createOption(createElement, option, value) {
            const isSelected = Array.isArray(value) ? value.includes(option.value) : value === option.value;
            return createElement("option", {
              domProps: {
                value: option.value,
                selected: isSelected,
                disabled: option.disabled
              }
            }, option.text);
          },
          inputHandler(e) {
            const target = e.target;
            let value;
            if (this.multiple) {
              value = Array.from(target.selectedOptions).map((o) => o.value);
            } else {
              value = target.value;
            }
            this.localValue = value;
          },
          blurHandler(e) {
            this.$emit("blur", e);
          },
          focusHandler(e) {
            this.$emit("focus", e);
          },
          blur() {
            this.$refs.select.blur();
          },
          focus(options) {
            this.$refs.select.focus(options);
          }
        }
      });
      const TButton = HtmlInput.extend({
        name: "TButton",
        props: {
          value: {
            type: [String, Number],
            default: null
          },
          text: {
            type: String,
            default: void 0
          },
          tagName: {
            type: String,
            default: "button",
            validator(value) {
              return ["button", "a"].indexOf(value) !== -1;
            }
          },
          type: {
            type: String,
            default: void 0
          },
          href: {
            type: String,
            default: null
          },
          to: {
            type: [String, Object],
            default: void 0
          },
          append: {
            type: Boolean,
            default: false
          },
          activeClass: {
            type: String,
            default: "router-link-active"
          },
          exact: {
            type: Boolean,
            default: false
          },
          exactActiveClass: {
            type: String,
            default: "router-link-exact-active"
          },
          event: {
            type: [String, Array],
            default: "click"
          },
          data: {
            type: Object,
            default: () => ({})
          },
          method: {
            type: String,
            default: "get"
          },
          replace: {
            type: Boolean,
            default: false
          },
          preserveScroll: {
            type: Boolean,
            default: false
          },
          preserveState: {
            type: Boolean,
            default: false
          },
          only: {
            type: Array,
            default: () => []
          },
          native: {
            type: Boolean,
            default: false
          },
          classes: {
            type: [String, Array, Object],
            default: "block px-4 py-2 text-white transition duration-100 ease-in-out bg-blue-500 border border-transparent rounded shadow-sm hover:bg-blue-600 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50  disabled:opacity-50 disabled:cursor-not-allowed"
          }
        },
        computed: {
          isInertiaLinkComponentAvailable() {
            return !!(this.$options.components && this.$options.components.InertiaLink);
          },
          isRouterLinkComponentAvailable() {
            return !!(this.$options.components && (this.$options.components.RouterLink || this.$options.components.NuxtLink));
          },
          isARouterLink() {
            return this.to !== void 0 && this.isRouterLinkComponentAvailable && !this.native;
          },
          isAnIntertiaLink() {
            return this.href !== null && this.tagName === "a" && this.isInertiaLinkComponentAvailable && !this.native;
          },
          componentToRender() {
            var _a;
            if (this.isARouterLink && this.$options.components) {
              return this.$options.components.NuxtLink || this.$options.components.RouterLink;
            }
            if (this.isAnIntertiaLink) {
              return (_a = this.$options.components) === null || _a === void 0 ? void 0 : _a.InertiaLink;
            }
            if (this.href) {
              return "a";
            }
            return this.tagName;
          }
        },
        render(createElement) {
          const renderFun = this.render;
          return renderFun(createElement);
        },
        methods: {
          blurHandler(e) {
            this.$emit("blur", e);
          },
          focusHandler(e) {
            this.$emit("focus", e);
          },
          clickHandler(e) {
            this.$emit("click", e);
          },
          keydownHandler(e) {
            this.$emit("keydown", e);
          },
          mousedownHandler(e) {
            this.$emit("mousedown", e);
          },
          blur() {
            this.$el.blur();
          },
          focus() {
            this.$el.focus();
          },
          inertiaLinkAttributes() {
            return {
              data: this.data,
              href: this.href,
              method: this.method,
              replace: this.replace,
              preserveScroll: this.preserveScroll,
              preserveState: this.preserveState,
              only: this.only,
              id: this.id,
              value: this.value,
              autofocus: this.autofocus,
              disabled: this.disabled,
              name: this.name,
              type: this.type
            };
          },
          routerLinkAttributes() {
            return {
              to: this.to,
              replace: this.replace,
              append: this.append,
              tag: this.tagName,
              activeClass: this.activeClass,
              exact: this.exact,
              event: this.event,
              exactActiveClass: this.exactActiveClass,
              id: this.id,
              value: this.value,
              autofocus: this.autofocus,
              disabled: this.disabled,
              name: this.name,
              type: this.type
            };
          },
          getAttributes() {
            if (this.isAnIntertiaLink) {
              return this.inertiaLinkAttributes();
            }
            if (this.isARouterLink) {
              return this.routerLinkAttributes();
            }
            return {
              id: this.id,
              value: this.value,
              autofocus: this.autofocus,
              disabled: this.disabled,
              name: this.name,
              href: this.href,
              type: this.type
            };
          },
          render(createElement) {
            return createElement(this.componentToRender, {
              attrs: this.getAttributes(),
              class: this.componentClass,
              on: this.getListeners({
                click: this.clickHandler,
                focus: this.focusHandler,
                blur: this.blurHandler,
                keydown: this.keydownHandler,
                mousedown: this.mousedownHandler
              })
            }, this.text === void 0 ? this.$slots.default : this.text);
          }
        }
      });
      class TRichSelectRenderer {
        constructor(createElement, component) {
          this.createElement = createElement;
          this.component = component;
        }
        render() {
          return this.createWrapper();
        }
        createWrapper() {
          return this.createElement("div", {
            ref: "wrapper",
            class: this.component.getElementCssClass("wrapper")
          }, [
            this.createSelectButtonWrapper(),
            this.createDropdown()
          ]);
        }
        createSelectButtonWrapper() {
          const subElements = [this.createSelectButton()];
          const hasSelectedOption = this.component.multiple ? this.component.selectedOptions.filter((o) => !o.disabled).length > 0 : !!(this.component.selectedOption && !this.component.selectedOption.disabled);
          if (this.component.clearable && hasSelectedOption && !this.component.disabled) {
            subElements.push(this.createSelectButtonClearButton());
          }
          return this.createElement("div", {
            ref: "buttonWrapper",
            class: this.component.getElementCssClass("buttonWrapper")
          }, subElements);
        }
        createSelectButton() {
          const subElements = [];
          if (this.component.multiple && this.component.selectedOptions.length) {
            if (this.component.$scopedSlots.label) {
              subElements.push(this.component.$scopedSlots.label({
                query: this.component.query,
                options: this.component.selectedOptions,
                className: this.component.getElementCssClass("selectButtonLabel")
              }));
            } else {
              subElements.push(this.createSelectButtonLabel());
            }
          } else if (!this.component.multiple && this.component.selectedOption) {
            if (this.component.$scopedSlots.label) {
              subElements.push(this.component.$scopedSlots.label({
                query: this.component.query,
                option: this.component.selectedOption,
                className: this.component.getElementCssClass("selectButtonLabel")
              }));
            } else {
              subElements.push(this.createSelectButtonLabel());
            }
          } else {
            subElements.push(this.createSelectButtonPlaceholder());
          }
          const hasSelectedOption = this.component.multiple ? this.component.selectedOptions.length > 0 : !!this.component.selectedOption;
          if (!(this.component.clearable && hasSelectedOption) && !this.component.disabled) {
            subElements.push(...this.createSelectButtonIcon());
          }
          if (this.component.multiple) {
            const hiddenInputs = this.component.selectedOptions.map((option) => this.createElement("input", {
              attrs: {
                type: "hidden",
                value: option.value,
                name: this.component.name
              }
            }));
            return this.createElement("div", {
              ref: "tagsContainer",
              attrs: {
                tabindex: this.component.tabindex || 0
              },
              class: this.component.getElementCssClass("selectButton"),
              on: {
                click: this.component.clickHandler,
                focus: this.component.focusHandler,
                keydown: (e) => {
                  if (e.keyCode === Key$1.DOWN) {
                    this.component.arrowDownHandler(e);
                  } else if (e.keyCode === Key$1.UP) {
                    this.component.arrowUpHandler(e);
                  } else if (e.keyCode === Key$1.ENTER) {
                    this.component.enterHandler(e);
                  } else if (e.keyCode === Key$1.ESC) {
                    this.component.escapeHandler(e);
                  }
                },
                blur: this.component.blurHandler,
                mousedown: (e) => {
                  e.preventDefault();
                }
              }
            }, subElements.concat(hiddenInputs));
          }
          return this.createElement("button", {
            ref: "selectButton",
            attrs: {
              type: "button",
              value: this.component.localValue,
              id: this.component.id,
              autofocus: this.component.autofocus,
              disabled: this.component.disabled,
              name: this.component.name
            },
            class: this.component.getElementCssClass("selectButton"),
            on: {
              click: this.component.clickHandler,
              focus: this.component.focusHandler,
              keydown: (e) => {
                if (e.keyCode === Key$1.DOWN) {
                  this.component.arrowDownHandler(e);
                } else if (e.keyCode === Key$1.UP) {
                  this.component.arrowUpHandler(e);
                } else if (e.keyCode === Key$1.ENTER) {
                  this.component.enterHandler(e);
                } else if (e.keyCode === Key$1.ESC) {
                  this.component.escapeHandler(e);
                }
              },
              blur: this.component.blurHandler,
              mousedown: (e) => {
                e.preventDefault();
              }
            }
          }, subElements);
        }
        createSelectButtonLabel() {
          if (this.component.multiple) {
            return this.createElement("div", {
              class: this.component.getElementCssClass("selectButtonTagWrapper")
            }, this.component.selectedOptions.map((selectedOption, index) => this.createElement("button", {
              class: this.component.getElementCssClass("selectButtonTag"),
              attrs: {
                tabindex: this.component.tagsAreFocusable && !selectedOption.disabled ? "0" : "-1",
                type: "button",
                disabled: selectedOption.disabled ? true : void 0
              },
              on: {
                click: (e) => {
                  e.stopPropagation();
                  if (selectedOption.disabled) {
                    return;
                  }
                  this.component.selectTag(e.currentTarget);
                },
                blur: (e) => {
                  this.component.unselectTag(e.currentTarget);
                },
                focus: (e) => {
                  this.component.selectTag(e.currentTarget);
                },
                keydown: (e) => {
                  if (e.keyCode === Key$1.BACKSPACE) {
                    this.component.unselectOptionAtIndex(index);
                  }
                }
              }
            }, [
              this.createElement("span", {
                class: this.component.getElementCssClass("selectButtonTagText")
              }, selectedOption ? selectedOption.text : ""),
              [
                selectedOption.disabled ? null : this.createElement("span", {
                  class: this.component.getElementCssClass("selectButtonTagDeleteButton"),
                  attrs: {
                    tabindex: -1
                  },
                  on: {
                    click: (e) => {
                      e.stopPropagation();
                      this.component.unselectOptionAtIndex(index);
                    }
                  }
                }, [
                  this.createElement("svg", {
                    class: this.component.getElementCssClass("selectButtonTagDeleteButtonIcon"),
                    attrs: {
                      fill: "currentColor",
                      viewBox: "0 0 20 20",
                      xmlns: "http://www.w3.org/2000/svg"
                    }
                  }, [
                    this.createElement("path", {
                      attrs: {
                        "fill-rule": "evenodd",
                        evenodd: "evenodd",
                        d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                      }
                    })
                  ])
                ])
              ]
            ])));
          }
          return this.createElement("span", {
            ref: "selectButtonLabel",
            class: this.component.getElementCssClass("selectButtonLabel")
          }, this.component.selectedOption ? this.component.selectedOption.text : "");
        }
        createSelectButtonPlaceholder() {
          const domProps = {};
          if (!this.component.placeholder) {
            domProps.innerHTML = "&nbsp;";
          }
          return this.createElement("span", {
            ref: "selectButtonPlaceholder",
            class: this.component.getElementCssClass("selectButtonPlaceholder"),
            domProps
          }, this.component.placeholder || void 0);
        }
        createSelectButtonIcon() {
          if (this.component.$scopedSlots.arrow) {
            return this.component.$scopedSlots.arrow({
              className: this.component.getElementCssClass("selectButtonIcon"),
              variant: this.component.variant,
              value: this.component.localValue
            });
          }
          return [this.createElement("svg", {
            ref: "selectButtonIcon",
            attrs: {
              fill: "currentColor",
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 20 20"
            },
            class: this.component.getElementCssClass("selectButtonIcon")
          }, [
            this.createElement("path", {
              attrs: {
                "clip-rule": "evenodd",
                "fill-rule": "evenodd",
                d: "M10 3a1 1 0 01.707.293l3 3a1 1 0 01-1.414 1.414L10 5.414 7.707 7.707a1 1 0 01-1.414-1.414l3-3A1 1 0 0110 3zm-3.707 9.293a1 1 0 011.414 0L10 14.586l2.293-2.293a1 1 0 011.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z"
              }
            })
          ])];
        }
        createSelectButtonClearButton() {
          return this.createElement("button", {
            ref: "selectButtonClearButton",
            class: this.component.getElementCssClass("selectButtonClearButton"),
            attrs: {
              type: "button",
              tabindex: -1
            },
            on: {
              click: this.component.clearButtonClickHandler
            }
          }, [
            this.createElement("svg", {
              attrs: {
                fill: "currentColor",
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 20 20"
              },
              class: this.component.getElementCssClass("selectButtonClearIcon")
            }, [
              this.createElement("polygon", {
                attrs: {
                  points: "10 8.58578644 2.92893219 1.51471863 1.51471863 2.92893219 8.58578644 10 1.51471863 17.0710678 2.92893219 18.4852814 10 11.4142136 17.0710678 18.4852814 18.4852814 17.0710678 11.4142136 10 18.4852814 2.92893219 17.0710678 1.51471863 10 8.58578644"
                }
              })
            ])
          ]);
        }
        createSearchBoxWrapper() {
          return this.createElement("div", {
            ref: "searchWrapper",
            class: this.component.getElementCssClass("searchWrapper")
          }, [
            this.createSearchBox()
          ]);
        }
        createSearchBox() {
          return this.createElement("input", {
            ref: "searchBox",
            class: this.component.getElementCssClass("searchBox"),
            domProps: {
              value: this.component.query
            },
            attrs: {
              placeholder: this.component.searchBoxPlaceholder
            },
            on: {
              keydown: (e) => {
                if (e.keyCode === Key$1.DOWN) {
                  this.component.arrowDownHandler(e);
                } else if (e.keyCode === Key$1.UP) {
                  this.component.arrowUpHandler(e);
                } else if (e.keyCode === Key$1.ENTER) {
                  this.component.enterHandler(e);
                } else if (e.keyCode === Key$1.ESC) {
                  this.component.escapeHandler(e);
                }
              },
              blur: this.component.blurHandler,
              input: this.component.searchInputHandler
            }
          });
        }
        getMinimumInputLengthText() {
          if (typeof this.component.minimumInputLengthText === "function") {
            return this.component.minimumInputLengthText(this.component.minimumInputLength, this.component.query);
          }
          return this.component.minimumInputLengthText;
        }
        createDropdown() {
          const subElements = [];
          if (this.component.shouldShowSearchbox) {
            subElements.push(this.createSearchBoxWrapper());
          }
          if (this.component.$scopedSlots.dropdownUp) {
            subElements.push(this.component.$scopedSlots.dropdownUp({
              query: this.component.query,
              selectedOption: this.component.selectedOption,
              options: this.component.filteredOptions
            }));
          }
          if (this.component.searching && !this.component.nextPage) {
            if (this.component.$scopedSlots.searchingText) {
              subElements.push(this.component.$scopedSlots.searchingText({
                text: this.component.searchingText,
                query: this.component.query,
                className: this.component.getElementCssClass("dropdownFeedback")
              }));
            } else {
              subElements.push(this.createDropdownFeedback(this.component.searchingText));
            }
          } else if (this.component.minimumInputLength !== void 0 && this.component.query.length < this.component.minimumInputLength) {
            const minInputLengthText = this.getMinimumInputLengthText();
            subElements.push(this.createDropdownFeedback(minInputLengthText));
          } else if (!this.component.filteredOptions.length) {
            if (this.component.$scopedSlots.noResults) {
              subElements.push(this.component.$scopedSlots.noResults({
                text: this.component.noResultsText,
                query: this.component.query,
                className: this.component.getElementCssClass("dropdownFeedback")
              }));
            } else {
              subElements.push(this.createDropdownFeedback(this.component.noResultsText));
            }
          }
          if (this.component.filteredOptions.length) {
            subElements.push(this.createOptionsList(this.component.filteredOptions));
          }
          if (this.component.searching && this.component.nextPage) {
            if (this.component.$scopedSlots.loadingMoreResultsText) {
              subElements.push(this.component.$scopedSlots.loadingMoreResultsText({
                text: this.component.loadingMoreResultsText,
                nextPage: this.component.nextPage,
                query: this.component.query,
                className: this.component.getElementCssClass("loadingMoreResults")
              }));
            } else {
              subElements.push(this.createLoadingMoreResults(this.component.loadingMoreResultsText));
            }
          }
          if (this.component.$scopedSlots.dropdownDown) {
            subElements.push(this.component.$scopedSlots.dropdownDown({
              query: this.component.query,
              selectedOption: this.component.selectedOption,
              options: this.component.filteredOptions
            }));
          }
          return this.createElement("transition", {
            props: {
              enterClass: this.component.getElementCssClass("enterClass"),
              enterActiveClass: this.component.getElementCssClass("enterActiveClass"),
              enterToClass: this.component.getElementCssClass("enterToClass"),
              leaveClass: this.component.getElementCssClass("leaveClass"),
              leaveActiveClass: this.component.getElementCssClass("leaveActiveClass"),
              leaveToClass: this.component.getElementCssClass("leaveToClass")
            }
          }, this.component.show ? [
            this.createElement("div", {
              ref: "dropdown",
              class: this.component.getElementCssClass("dropdown")
            }, subElements)
          ] : void 0);
        }
        createOptionsList(options) {
          return this.createElement("ul", {
            ref: "optionsList",
            class: this.component.getElementCssClass("optionsList"),
            style: {
              maxHeight: this.component.normalizedHeight
            },
            on: {
              scroll: this.component.listScrollHandler
            }
          }, this.createOptions(options));
        }
        createDropdownFeedback(text) {
          return this.createElement("div", {
            ref: "dropdownFeedback",
            class: this.component.getElementCssClass("dropdownFeedback")
          }, text);
        }
        createLoadingMoreResults(text) {
          return this.createElement("div", {
            ref: "loadingMoreResults",
            class: this.component.getElementCssClass("loadingMoreResults")
          }, text);
        }
        createOptions(options) {
          let index = -1;
          return options.map((option) => {
            if (option.children) {
              return [
                option,
                ...option.children
              ];
            }
            return option;
          }).flat().map((option) => {
            if (option.children) {
              return this.createOptgroup(option);
            }
            index += 1;
            return this.createOption(option, index);
          });
        }
        createOptgroup(optgroup) {
          return this.createElement("li", {
            attrs: {
              "data-type": "optgroup"
            },
            class: this.component.getElementCssClass("optgroup")
          }, guessOptionText(optgroup, this.component.textAttribute));
        }
        createOption(option, index) {
          const isSelected = this.component.optionHasValue(option, this.component.localValue);
          const isHighlighted = this.component.highlighted === index;
          let className;
          if (option.disabled) {
            className = this.component.getElementCssClass("disabledOption");
          } else if (isHighlighted && isSelected) {
            className = this.component.getElementCssClass("selectedHighlightedOption");
          } else if (isHighlighted) {
            className = this.component.getElementCssClass("highlightedOption");
          } else if (isSelected) {
            className = this.component.getElementCssClass("selectedOption");
          } else {
            className = this.component.getElementCssClass("option");
          }
          const subElements = [];
          if (this.component.$scopedSlots.option) {
            subElements.push(this.component.$scopedSlots.option({
              index,
              isHighlighted,
              isSelected,
              option,
              query: this.component.query,
              className: this.component.getElementCssClass("optionContent")
            }));
          } else {
            subElements.push(this.createOptionContent(option, isSelected));
          }
          return this.createElement("li", {
            ref: "option",
            class: className,
            attrs: {
              "data-type": "option"
            },
            on: {
              mouseover: () => {
                this.component.highlighted = index;
              },
              mouseleave: () => {
                this.component.highlighted = null;
              },
              mousedown: (e) => {
                e.preventDefault();
              },
              click: (e) => {
                e.preventDefault();
                if (option.disabled) {
                  return;
                }
                this.component.selectOption(option);
              }
            }
          }, subElements);
        }
        createOptionContent(option, isSelected) {
          const subElements = [
            this.createOptionLabel(option)
          ];
          if (isSelected) {
            subElements.push(this.createOptionSelectedIcon());
          }
          return this.createElement("div", {
            ref: "optionContent",
            class: this.component.getElementCssClass("optionContent")
          }, subElements);
        }
        createOptionLabel(option) {
          return this.createElement("span", {
            ref: "optionLabel",
            class: this.component.getElementCssClass("optionLabel")
          }, option.text);
        }
        createOptionSelectedIcon() {
          return this.createElement("svg", {
            ref: "selectedIcon",
            attrs: {
              fill: "currentColor",
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 20 20"
            },
            class: this.component.getElementCssClass("selectedIcon")
          }, [
            this.createElement("polygon", {
              attrs: {
                points: "0 11 2 9 7 14 18 3 20 5 7 18"
              }
            })
          ]);
        }
      }
      const TRichSelect = MultipleInput.extend({
        name: "TRichSelect",
        render(createElement) {
          const createSelectFunc = this.createSelect;
          return createSelectFunc(createElement);
        },
        props: {
          delay: {
            type: Number,
            default: 250
          },
          fetchOptions: {
            type: Function,
            default: void 0
          },
          minimumResultsForSearch: {
            type: Number,
            default: void 0
          },
          minimumInputLength: {
            type: Number,
            default: void 0
          },
          minimumInputLengthText: {
            type: [Function, String],
            default: (minimumInputLength, _query) => `Please enter ${minimumInputLength} or more characters`
          },
          hideSearchBox: {
            type: Boolean,
            default: false
          },
          openOnFocus: {
            type: Boolean,
            default: true
          },
          closeOnSelect: {
            type: Boolean,
            default: true
          },
          selectOnClose: {
            type: Boolean,
            default: false
          },
          clearable: {
            type: Boolean,
            default: false
          },
          multiple: {
            type: Boolean,
            default: false
          },
          placeholder: {
            type: String,
            default: void 0
          },
          searchBoxPlaceholder: {
            type: String,
            default: "Search..."
          },
          noResultsText: {
            type: String,
            default: "No results found"
          },
          searchingText: {
            type: String,
            default: "Searching..."
          },
          loadingMoreResultsText: {
            type: String,
            default: "Loading more results..."
          },
          maxHeight: {
            type: [String, Number],
            default: 300
          },
          fixedClasses: {
            type: Object,
            default() {
              return {
                wrapper: "relative",
                buttonWrapper: "inline-block relative w-full",
                selectButton: "w-full flex text-left justify-between items-center",
                selectButtonLabel: "block truncate",
                selectButtonTagWrapper: "flex flex-wrap overflow-hidden",
                selectButtonTag: "bg-blue-500 block disabled:cursor-not-allowed disabled:opacity-50 duration-100 ease-in-out focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 rounded shadow-sm text-sm text-white transition whitespace-nowrap m-0.5 max-w-full overflow-hidden h-8 flex items-center",
                selectButtonTagText: "px-3",
                selectButtonTagDeleteButton: "-ml-1.5 h-full hover:bg-blue-600 hover:shadow-sm inline-flex items-center px-2 transition",
                selectButtonTagDeleteButtonIcon: "w-3 h-3",
                selectButtonPlaceholder: "block truncate",
                selectButtonIcon: "fill-current flex-shrink-0 ml-1 h-4 w-4",
                selectButtonClearButton: "flex flex-shrink-0 items-center justify-center absolute right-0 top-0 m-2 h-6 w-6",
                selectButtonClearIcon: "fill-current h-3 w-3",
                dropdown: "absolute w-full z-10",
                dropdownFeedback: "",
                loadingMoreResults: "",
                optionsList: "overflow-auto",
                searchWrapper: "inline-block w-full",
                searchBox: "inline-block w-full",
                optgroup: "",
                option: "cursor-pointer",
                disabledOption: "opacity-50 cursor-not-allowed",
                highlightedOption: "cursor-pointer",
                selectedOption: "cursor-pointer",
                selectedHighlightedOption: "cursor-pointer",
                optionContent: "",
                optionLabel: "truncate block",
                selectedIcon: "fill-current h-4 w-4",
                enterClass: "",
                enterActiveClass: "",
                enterToClass: "",
                leaveClass: "",
                leaveActiveClass: "",
                leaveToClass: ""
              };
            }
          },
          classes: {
            type: Object,
            default() {
              return {
                wrapper: "",
                buttonWrapper: "",
                selectButton: "px-3 py-2 text-black transition duration-100 ease-in-out bg-white border border-gray-300 rounded shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed",
                selectButtonLabel: "",
                selectButtonTagWrapper: "-mx-2 -my-2.5 py-1 pr-8",
                selectButtonTag: "bg-blue-500 block disabled:cursor-not-allowed disabled:opacity-50 duration-100 ease-in-out focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 rounded shadow-sm text-sm text-white transition whitespace-nowrap m-0.5 max-w-full overflow-hidden h-8 flex items-center",
                selectButtonTagText: "px-3",
                selectButtonTagDeleteButton: "-ml-1.5 h-full hover:bg-blue-600 hover:shadow-sm inline-flex items-center px-2 transition",
                selectButtonTagDeleteButtonIcon: "",
                selectButtonPlaceholder: "text-gray-400",
                selectButtonIcon: "text-gray-600",
                selectButtonClearButton: "hover:bg-blue-100 text-gray-600 rounded transition duration-100 ease-in-out",
                selectButtonClearIcon: "",
                dropdown: "-mt-1 bg-white border-b border-gray-300 border-l border-r rounded-b shadow-sm",
                dropdownFeedback: "pb-2 px-3 text-gray-400 text-sm",
                loadingMoreResults: "pb-2 px-3 text-gray-400 text-sm",
                optionsList: "",
                searchWrapper: "p-2 placeholder-gray-400",
                searchBox: "px-3 py-2 bg-gray-50 text-sm rounded border focus:outline-none focus:shadow-outline border-gray-300",
                optgroup: "text-gray-400 uppercase text-xs py-1 px-2 font-semibold",
                option: "",
                disabledOption: "",
                highlightedOption: "bg-blue-100",
                selectedOption: "font-semibold bg-gray-100 bg-blue-500 font-semibold text-white",
                selectedHighlightedOption: "font-semibold bg-gray-100 bg-blue-600 font-semibold text-white",
                optionContent: "flex justify-between items-center px-3 py-2",
                optionLabel: "",
                selectedIcon: "",
                enterClass: "opacity-0",
                enterActiveClass: "transition ease-out duration-100",
                enterToClass: "opacity-100",
                leaveClass: "opacity-100",
                leaveActiveClass: "transition ease-in duration-75",
                leaveToClass: "opacity-0"
              };
            }
          }
        },
        data() {
          return {
            hasFocus: false,
            show: false,
            localValue: this.value,
            highlighted: null,
            query: "",
            filteredOptions: [],
            selectedOption: void 0,
            selectedOptions: [],
            searching: false,
            delayTimeout: void 0,
            nextPage: void 0,
            tagsAreFocusable: false
          };
        },
        created() {
          if (Array.isArray(this.value)) {
            this.selectedOptions = this.value.map((value) => this.findOptionByValue(value)).filter((option) => !!option);
          } else if (!this.selectedOption || this.selectedOption.value !== this.value) {
            this.selectedOption = this.findOptionByValue(this.value);
          }
        },
        updated() {
          if (typeof this.selectedOption === "undefined" || !Array.isArray(this.value) && this.selectedOption.value !== this.value && this.value !== null) {
            this.selectedOption = this.findOptionByValue(this.value);
          }
        },
        watch: {
          normalizedOptions: {
            handler() {
              this.query = "";
              this.filterOptions("");
            },
            immediate: true
          },
          query(query) {
            this.nextPage = void 0;
            this.filterOptions(query);
          },
          localValue(localValue) {
            return __awaiter(this, void 0, void 0, function* () {
              if (Array.isArray(localValue)) {
                this.selectedOptions = localValue.map((value) => this.findOptionByValue(value)).filter((option) => !!option);
              } else if (!this.selectedOption || this.selectedOption.value !== localValue) {
                this.selectedOption = this.findOptionByValue(localValue);
              }
              this.$emit("input", localValue);
              yield this.$nextTick();
              this.$emit("change", localValue);
              if (this.closeOnSelect) {
                this.hideOptions();
              }
            });
          },
          value(value) {
            this.localValue = value;
          },
          highlighted(highlighted) {
            return __awaiter(this, void 0, void 0, function* () {
              if (highlighted === null) {
                return;
              }
              yield this.$nextTick();
              this.scrollToHighlightedOption();
            });
          },
          show(show) {
            if (show) {
              if (this.shouldShowSearchbox) {
                this.focusSearchBox();
              }
              if (!this.atLeastOneValidOptionExists) {
                this.highlighted = null;
                return;
              }
              this.highlighted = this.selectedOptionIndex !== void 0 ? this.selectedOptionIndex : this.findNextOptionIndex();
            }
          },
          shouldShowSearchbox(shouldShowSearchbox) {
            if (shouldShowSearchbox && this.show) {
              this.focusSearchBox();
            }
          }
        },
        computed: {
          usesAjax() {
            return !!this.fetchOptions;
          },
          shouldShowSearchbox() {
            const showSearchbox = !this.hideSearchBox;
            const hasQuery = !!this.query;
            const hasMinResultsSetting = typeof this.minimumResultsForSearch === "undefined";
            const hasminimumResultsForSearch = hasMinResultsSetting || hasQuery || (this.usesAjax ? this.filteredflattenedOptions.length >= this.minimumResultsForSearch : this.normalizedOptions.length >= this.minimumResultsForSearch);
            return showSearchbox && hasminimumResultsForSearch;
          },
          hasMinimumInputLength() {
            return this.minimumInputLength === void 0 || this.query.length >= this.minimumInputLength;
          },
          flattenedOptions() {
            return this.normalizedOptions.map((option) => {
              if (option.children) {
                return option.children;
              }
              return option;
            }).flat();
          },
          filteredflattenedOptions() {
            return this.filteredOptions.map((option) => {
              if (option.children) {
                return option.children;
              }
              return option;
            }).flat();
          },
          atLeastOneValidOptionExists() {
            return this.filteredflattenedOptions.some((option) => !option.disabled);
          },
          normalizedHeight() {
            if (/^\d+$/.test(String(this.maxHeight))) {
              return `${this.maxHeight}px`;
            }
            return String(this.maxHeight);
          },
          selectedOptionIndex() {
            let selectedOption;
            if (this.multiple) {
              selectedOption = this.selectedOptions.length >= 1 ? this.selectedOptions[this.selectedOptions.length - 1] : void 0;
            } else {
              selectedOption = this.selectedOption;
            }
            if (!selectedOption) {
              return void 0;
            }
            const index = this.filteredflattenedOptions.findIndex((option) => this.optionHasValue(option, selectedOption.value));
            return index >= 0 ? index : void 0;
          },
          highlightedOption() {
            if (typeof this.highlighted === "number") {
              return this.filteredflattenedOptions[this.highlighted];
            }
            return void 0;
          }
        },
        methods: {
          findOptionByValue(value) {
            if (this.usesAjax) {
              return [...this.filteredflattenedOptions, ...this.selectedOptions].find((option) => this.optionHasValue(option, value));
            }
            return this.flattenedOptions.find((option) => this.optionHasValue(option, value));
          },
          optionHasValue(option, value) {
            return Array.isArray(value) ? value.includes(option.value) : value === option.value;
          },
          createSelect(createElement) {
            return new TRichSelectRenderer(createElement, this).render();
          },
          filterOptions(query) {
            return __awaiter(this, void 0, void 0, function* () {
              if (!this.hasMinimumInputLength) {
                this.filteredOptions = [];
                return;
              }
              if (!this.fetchOptions) {
                const options = cloneDeep__default["default"](this.normalizedOptions);
                this.filteredOptions = this.queryFilter(options);
                if (this.filteredOptions.length) {
                  this.highlighted = 0;
                } else {
                  this.highlighted = null;
                }
                return;
              }
              this.searching = true;
              if (this.delayTimeout) {
                clearTimeout(this.delayTimeout);
              }
              this.delayTimeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                try {
                  const { results, hasMorePages } = yield this.getFilterPromise(query);
                  if (this.nextPage) {
                    const currentOptionsListLength = this.filteredOptions.length;
                    this.filteredOptions = this.filteredOptions.concat(this.normalizeOptions(results));
                    if (this.highlighted === currentOptionsListLength - 1) {
                      this.highlighted = currentOptionsListLength;
                    }
                  } else {
                    this.filteredOptions = this.normalizeOptions(results);
                    if (this.filteredOptions.length) {
                      this.highlighted = 0;
                    } else {
                      this.highlighted = null;
                    }
                  }
                  if (hasMorePages) {
                    this.nextPage = this.nextPage === void 0 ? 2 : this.nextPage + 1;
                  } else {
                    this.nextPage = void 0;
                  }
                } catch (error) {
                  this.$emit("fetch-error", error);
                  this.filteredOptions = [];
                }
                this.searching = false;
                this.delayTimeout = void 0;
              }), this.delay);
            });
          },
          getFilterPromise(query) {
            return Promise.resolve(this.fetchOptions(query, this.nextPage));
          },
          listEndReached() {
            if (!this.nextPage || this.searching) {
              return;
            }
            this.filterOptions(this.query);
          },
          queryFilter(options) {
            if (!this.query) {
              return options;
            }
            return options.map((option) => {
              if (option.children) {
                const newOption = Object.assign(Object.assign({}, option), {
                  children: this.queryFilter(option.children)
                });
                return newOption;
              }
              return option;
            }).filter((option) => {
              const foundText = String(option.text).toUpperCase().trim().includes(this.query.toUpperCase().trim());
              const hasChildren = option.children && option.children.length > 0;
              return hasChildren || foundText;
            });
          },
          hideOptions() {
            this.show = false;
            if (this.selectOnClose && this.highlightedOption) {
              this.selectOption(this.highlightedOption, false);
            }
          },
          showOptions() {
            this.show = true;
          },
          toggleOptions() {
            if (this.show) {
              this.hideOptions();
            } else {
              this.showOptions();
            }
          },
          focusSearchBox() {
            return __awaiter(this, void 0, void 0, function* () {
              yield this.$nextTick();
              const searchBox = this.getSearchBox();
              searchBox.focus();
              searchBox.select();
            });
          },
          blurHandler(e) {
            let shouldHideOptions = true;
            const clickedElement = e.relatedTarget;
            if (clickedElement) {
              const wrapper = this.$refs.wrapper;
              const isChild = wrapper.contains(clickedElement);
              let clickedATag = false;
              if (this.multiple) {
                clickedATag = this.$refs.tagsContainer.contains(clickedElement);
              }
              if (isChild && !clickedATag) {
                shouldHideOptions = false;
              }
            }
            if (clickedElement !== this.$refs.selectButton && !shouldHideOptions && this.getSearchBox()) {
              this.focusSearchBox();
              return;
            }
            if (shouldHideOptions) {
              this.hideOptions();
            }
            this.$emit("blur", e);
            this.hasFocus = false;
          },
          focusHandler(e) {
            this.hasFocus = true;
            if (this.openOnFocus) {
              this.showOptions();
            }
            this.$emit("focus", e);
          },
          clickHandler(e) {
            if (!this.show && !this.hasFocus) {
              if (this.multiple) {
                this.getTagsContainer().focus();
              } else {
                this.getButton().focus();
              }
              if (!this.openOnFocus) {
                this.showOptions();
              }
            } else {
              this.toggleOptions();
            }
            this.$emit("click", e);
          },
          findNextOptionIndex(currentOptionIndex = null) {
            const endReached = currentOptionIndex !== null && currentOptionIndex + 1 >= this.filteredflattenedOptions.length;
            let nextOptionIndex;
            if (currentOptionIndex === null || endReached) {
              nextOptionIndex = 0;
            } else {
              nextOptionIndex = currentOptionIndex + 1;
            }
            const nextOption = this.filteredflattenedOptions[nextOptionIndex];
            if (!nextOption || nextOption.disabled) {
              return this.findNextOptionIndex(nextOptionIndex);
            }
            return nextOptionIndex;
          },
          findPrevOptionIndex(currentOptionIndex) {
            const beginningReached = currentOptionIndex === null || currentOptionIndex - 1 < 0;
            let prevOptionIndex;
            if (currentOptionIndex === null || beginningReached) {
              prevOptionIndex = this.filteredflattenedOptions.length - 1;
            } else {
              prevOptionIndex = currentOptionIndex - 1;
            }
            const prevOption = this.filteredflattenedOptions[prevOptionIndex];
            if (!prevOption || prevOption.disabled) {
              return this.findPrevOptionIndex(prevOptionIndex);
            }
            return prevOptionIndex;
          },
          arrowUpHandler(e) {
            return __awaiter(this, void 0, void 0, function* () {
              e.preventDefault();
              if (!this.show) {
                this.showOptions();
                return;
              }
              if (!this.atLeastOneValidOptionExists) {
                this.highlighted = null;
                return;
              }
              this.highlighted = this.findPrevOptionIndex(this.highlighted);
            });
          },
          arrowDownHandler(e) {
            e.preventDefault();
            if (!this.show) {
              this.showOptions();
              return;
            }
            if (!this.atLeastOneValidOptionExists) {
              this.highlighted = null;
              return;
            }
            const nextOptionIndex = this.findNextOptionIndex(this.highlighted);
            const endReached = nextOptionIndex >= this.filteredflattenedOptions.length;
            if (endReached && this.usesAjax && this.nextPage) {
              this.listEndReached();
            } else {
              this.highlighted = nextOptionIndex;
            }
          },
          listScrollHandler(e) {
            const el = e.target;
            if (el.scrollTop === el.scrollHeight - el.offsetHeight) {
              this.listEndReached();
            }
          },
          scrollToHighlightedOption(behavior = "auto") {
            if (this.$refs.optionsList && typeof this.highlighted === "number") {
              const list = this.$refs.optionsList;
              const li = list.querySelectorAll("li[data-type=option]")[this.highlighted];
              if (li.scrollIntoView) {
                li.scrollIntoView({ block: "nearest", behavior });
              }
            }
          },
          escapeHandler(e) {
            e.preventDefault();
            this.hideOptions();
          },
          enterHandler(e) {
            if (!this.show) {
              return;
            }
            if (this.highlighted !== null) {
              e.preventDefault();
              this.selectOption(this.highlightedOption);
            }
          },
          searchInputHandler(e) {
            const target = e.target;
            this.query = target.value;
          },
          getButton() {
            return this.$refs.selectButton;
          },
          getTagsContainer() {
            return this.$refs.tagsContainer;
          },
          getSearchBox() {
            return this.$refs.searchBox;
          },
          selectOption(option, focus = true) {
            return __awaiter(this, void 0, void 0, function* () {
              const optionValue = option.value;
              if (this.multiple) {
                if (Array.isArray(this.localValue)) {
                  const valueIndex = this.localValue.findIndex((value) => isEqual__default["default"](value, optionValue));
                  if (valueIndex >= 0) {
                    this.localValue.splice(valueIndex, 1);
                    const selectedOptionIndex = this.selectedOptions.findIndex((o) => o.value === optionValue);
                    if (selectedOptionIndex >= 0) {
                      this.unselectOptionAtIndex(selectedOptionIndex);
                      this.selectedOptions.splice(selectedOptionIndex, 1);
                    }
                  } else {
                    this.localValue.push(optionValue);
                    this.selectedOptions.push(option);
                  }
                } else {
                  this.localValue = [optionValue];
                  this.selectedOptions.push(option);
                }
              } else {
                if (this.localValue !== optionValue) {
                  this.localValue = optionValue;
                }
                this.selectedOption = option;
              }
              yield this.$nextTick();
              if (focus) {
                if (!this.closeOnSelect && this.shouldShowSearchbox) {
                  this.getSearchBox().focus();
                } else {
                  if (this.multiple) {
                    this.getTagsContainer().focus();
                  } else {
                    this.getButton().focus();
                  }
                  if (this.closeOnSelect && this.show) {
                    this.hideOptions();
                  }
                }
              }
            });
          },
          unselectOptionAtIndex(index) {
            const selectedOption = this.selectedOptions[index];
            const valueIndex = this.localValue.findIndex((value) => isEqual__default["default"](value, selectedOption.value));
            if (valueIndex >= 0) {
              this.localValue.splice(valueIndex, 1);
            }
          },
          clearButtonClickHandler(e) {
            e.preventDefault();
            e.stopPropagation();
            if (this.multiple) {
              this.localValue = this.selectedOptions.filter((o) => !!o.disabled).map((o) => o.value);
            } else {
              this.localValue = null;
            }
            this.query = "";
          },
          blur() {
            const el = this.hideSearchBox ? this.$refs.selectButton : this.$refs.searchBox;
            el.blur();
          },
          focus(options) {
            const el = this.$refs.selectButton;
            el.focus(options);
          },
          selectTag(tag) {
            return __awaiter(this, void 0, void 0, function* () {
              this.tagsAreFocusable = true;
              yield this.$nextTick();
              tag.focus();
            });
          },
          unselectTag() {
            return __awaiter(this, void 0, void 0, function* () {
              this.tagsAreFocusable = false;
            });
          }
        }
      });
      const TInputGroup = Component.extend({
        name: "TInputGroup",
        props: {
          inputName: {
            type: String,
            default: void 0
          },
          label: {
            type: String,
            default: void 0
          },
          description: {
            type: String,
            default: void 0
          },
          feedback: {
            type: String,
            default: void 0
          },
          sortedElements: {
            type: Array,
            default: () => ["label", "default", "feedback", "description"],
            validator(value) {
              const expectedValues = ["default", "description", "feedback", "label"];
              return value.length === intersection__default["default"](value, expectedValues).length;
            }
          },
          fixedClasses: {
            type: Object,
            default() {
              return {};
            }
          },
          classes: {
            type: Object,
            default() {
              return {
                wrapper: "",
                label: "block",
                body: "",
                feedback: "text-gray-400 text-sm",
                description: "text-gray-400 text-sm"
              };
            }
          }
        },
        render(createElement) {
          const renderFun = this.render;
          return renderFun(createElement);
        },
        computed: {
          elementsToRender() {
            const props = this.$props;
            const slots = this.$slots;
            return this.sortedElements.filter((e) => e === "default" || !!props[e] || !!slots[e]);
          }
        },
        methods: {
          render(createElement) {
            return createElement("div", {
              ref: "wrapper",
              class: this.getElementCssClass("wrapper")
            }, this.elementsToRender.map((elementName) => createElement(this.getTagName(elementName), {
              ref: elementName,
              class: this.getElementCssClass(elementName === "default" ? "body" : elementName),
              attrs: {
                for: elementName === "label" ? this.inputName : void 0
              },
              slot: elementName
            }, this.$slots[elementName] || this.$props[elementName])));
          },
          getTagName(slotName) {
            switch (slotName) {
              case "label":
                return "label";
              default:
                return "div";
            }
          }
        }
      });
      const TCard = Component.extend({
        name: "TCard",
        props: {
          tagName: {
            type: String,
            default: "div"
          },
          header: {
            type: String,
            default: void 0
          },
          footer: {
            type: String,
            default: void 0
          },
          noBody: {
            type: Boolean,
            default: false
          },
          classes: {
            type: Object,
            default: () => ({
              wrapper: "border rounded shadow-sm bg-white border-gray-100",
              body: "p-3",
              header: "border-b border-gray-100 p-3 rounded-t",
              footer: "border-gray-100 border-t p-3 rounded-b"
            })
          }
        },
        render(createElement) {
          const renderFun = this.render;
          return renderFun(createElement);
        },
        methods: {
          render(createElement) {
            return createElement(this.tagName, {
              class: this.getElementCssClass("wrapper")
            }, this.renderChilds(createElement));
          },
          renderChilds(createElement) {
            if (this.noBody) {
              return this.$slots.default;
            }
            const childs = [];
            if (!!this.$slots.header || this.header !== void 0) {
              childs.push(createElement("div", {
                ref: "header",
                class: this.getElementCssClass("header")
              }, this.$slots.header || this.header));
            }
            childs.push(createElement("div", {
              ref: "body",
              class: this.getElementCssClass("body")
            }, this.$slots.default));
            if (!!this.$slots.footer || this.footer !== void 0) {
              childs.push(createElement("div", {
                ref: "footer",
                class: this.getElementCssClass("footer")
              }, this.$slots.footer || this.footer));
            }
            return childs;
          }
        }
      });
      const TAlert = Component.extend({
        name: "TAlert",
        props: {
          tagName: {
            type: String,
            default: "div"
          },
          bodyTagName: {
            type: String,
            default: "div"
          },
          dismissible: {
            type: Boolean,
            default: true
          },
          show: {
            type: Boolean,
            default: false
          },
          timeout: {
            type: Number,
            default: void 0
          },
          classes: {
            type: Object,
            default() {
              return {
                wrapper: "relative flex items-center p-4 bg-blue-50 border-l-4 border-blue-500 rounded shadow-sm",
                body: "flex-grow",
                close: "absolute relative flex items-center justify-center flex-shrink-0 w-6 h-6 ml-4 text-blue-500 transition duration-100 ease-in-out rounded hover:bg-blue-200 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
                closeIcon: "fill-current h-4 w-4"
              };
            }
          }
        },
        data() {
          return {
            localShow: this.show
          };
        },
        render(createElement) {
          const renderFun = this.render;
          return renderFun(createElement);
        },
        watch: {
          show(show) {
            this.localShow = show;
          },
          localShow(localShow) {
            this.$emit("update:show", localShow);
            if (this.localShow) {
              this.$emit("shown");
              if (this.timeout) {
                this.initTimeout();
              }
            } else {
              this.$emit("hidden");
            }
          }
        },
        mounted() {
          if (this.localShow && this.timeout) {
            this.initTimeout();
          }
        },
        methods: {
          render(createElement) {
            if (!this.localShow) {
              return createElement();
            }
            return createElement(this.tagName, {
              class: this.getElementCssClass("wrapper")
            }, !this.dismissible ? [
              createElement(this.bodyTagName, {
                ref: "body",
                class: this.getElementCssClass("body")
              }, this.$slots.default)
            ] : [
              createElement(this.bodyTagName, {
                ref: "body",
                class: this.getElementCssClass("body")
              }, this.$slots.default),
              createElement("button", {
                ref: "close",
                class: this.getElementCssClass("close"),
                attrs: {
                  type: "button"
                },
                on: {
                  click: this.hide
                }
              }, this.$slots.close || [
                createElement("svg", {
                  attrs: {
                    fill: "currentColor",
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 0 20 20"
                  },
                  class: this.getElementCssClass("closeIcon")
                }, [
                  createElement("path", {
                    attrs: {
                      "clip-rule": "evenodd",
                      "fill-rule": "evenodd",
                      d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                    }
                  })
                ])
              ])
            ]);
          },
          initTimeout() {
            setTimeout(() => {
              this.hide();
            }, this.timeout);
          },
          hide() {
            this.localShow = false;
          }
        }
      });
      const TModal = Component.extend({
        name: "TModal",
        props: {
          name: {
            type: String,
            default: void 0
          },
          value: {
            type: Boolean,
            default: false
          },
          header: {
            type: String,
            default: void 0
          },
          footer: {
            type: String,
            default: void 0
          },
          clickToClose: {
            type: Boolean,
            default: true
          },
          escToClose: {
            type: Boolean,
            default: true
          },
          noBody: {
            type: Boolean,
            default: false
          },
          hideCloseButton: {
            type: Boolean,
            default: false
          },
          disableBodyScroll: {
            type: Boolean,
            default: true
          },
          bodyScrollLockOptions: {
            type: Object,
            default: () => ({})
          },
          focusOnOpen: {
            type: Boolean,
            default: true
          },
          fixedClasses: {
            type: Object,
            default() {
              return {
                overlay: "overflow-auto scrolling-touch left-0 top-0 bottom-0 right-0 w-full h-full fixed",
                wrapper: "relative mx-auto",
                modal: "overflow-visible relative ",
                close: "flex items-center justify-center"
              };
            }
          },
          classes: {
            type: Object,
            default() {
              return {
                overlay: "z-40 bg-black bg-opacity-50",
                wrapper: "z-50 max-w-lg px-3 py-12",
                modal: "bg-white shadow rounded",
                body: "p-3",
                header: "border-b border-gray-100 p-3 rounded-t",
                footer: "bg-gray-100 p-3 rounded-b",
                close: "bg-gray-100 text-gray-600 rounded-full absolute right-0 top-0 -m-3 h-8 w-8 transition duration-100 ease-in-out hover:bg-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
                closeIcon: "fill-current h-4 w-4",
                overlayEnterClass: "opacity-0",
                overlayEnterActiveClass: "transition ease-out duration-100",
                overlayEnterToClass: "opacity-100",
                overlayLeaveClass: "opacity-100",
                overlayLeaveActiveClass: "transition ease-in duration-75",
                overlayLeaveToClass: "opacity-0",
                enterClass: "",
                enterActiveClass: "",
                enterToClass: "",
                leaveClass: "",
                leaveActiveClass: "",
                leaveToClass: ""
              };
            }
          }
        },
        data() {
          return {
            overlayShow: this.value,
            modalShow: this.value,
            params: void 0,
            preventAction: false
          };
        },
        watch: {
          value(value) {
            if (value) {
              this.show();
            } else {
              this.hide();
            }
          },
          overlayShow(shown) {
            return __awaiter(this, void 0, void 0, function* () {
              this.$emit("input", shown);
              this.$emit("change", shown);
              yield this.$nextTick();
              if (shown) {
                this.modalShow = true;
              } else {
                this.closed();
              }
            });
          },
          modalShow(shown) {
            return __awaiter(this, void 0, void 0, function* () {
              yield this.$nextTick();
              if (!shown) {
                this.overlayShow = false;
              } else {
                this.opened();
              }
            });
          }
        },
        created() {
          if (this.name && this.$modal) {
            this.$modal.$on(`show-${this.name}`, (params = void 0) => {
              this.show(params);
            });
            this.$modal.$on(`hide-${this.name}`, () => {
              this.hide();
            });
          }
        },
        mounted() {
          if (this.overlayShow) {
            this.prepareDomForModal();
          }
        },
        beforeDestroy() {
          const overlay = this.getOverlay();
          if (this.disableBodyScroll && overlay) {
            overlay.focus();
            bodyScrollLock.enableBodyScroll(overlay);
          }
        },
        render(createElement) {
          const renderFun = this.render;
          return renderFun(createElement);
        },
        methods: {
          render(createElement) {
            return createElement("transition", {
              props: {
                enterClass: this.getElementCssClass("overlayEnterClass"),
                enterActiveClass: this.getElementCssClass("overlayEnterActiveClass"),
                enterToClass: this.getElementCssClass("overlayEnterToClass"),
                leaveClass: this.getElementCssClass("overlayLeaveClass"),
                leaveActiveClass: this.getElementCssClass("overlayLeaveActiveClass"),
                leaveToClass: this.getElementCssClass("overlayLeaveToClass")
              }
            }, this.overlayShow ? [
              createElement("div", {
                ref: "overlay",
                attrs: {
                  tabindex: 0
                },
                class: this.getElementCssClass("overlay"),
                on: {
                  keyup: this.keyupHandler,
                  click: this.clickHandler
                }
              }, [
                this.renderWrapper(createElement)
              ])
            ] : void 0);
          },
          renderWrapper(createElement) {
            return createElement("div", {
              ref: "wrapper",
              class: this.getElementCssClass("wrapper")
            }, [
              this.renderModal(createElement)
            ]);
          },
          renderModal(createElement) {
            return createElement("transition", {
              props: {
                enterClass: this.getElementCssClass("enterClass"),
                enterActiveClass: this.getElementCssClass("enterActiveClass"),
                enterToClass: this.getElementCssClass("enterToClass"),
                leaveClass: this.getElementCssClass("leaveClass"),
                leaveActiveClass: this.getElementCssClass("leaveActiveClass"),
                leaveToClass: this.getElementCssClass("leaveToClass")
              }
            }, this.modalShow ? [
              createElement("div", {
                ref: "modal",
                class: this.getElementCssClass("modal")
              }, this.renderChilds(createElement))
            ] : void 0);
          },
          renderChilds(createElement) {
            if (this.noBody) {
              return this.$slots.default;
            }
            const childs = [];
            if (!this.hideCloseButton) {
              childs.push(createElement("button", {
                ref: "close",
                class: this.getElementCssClass("close"),
                attrs: {
                  type: "button"
                },
                on: {
                  click: this.hide
                }
              }, this.$slots.button || [
                createElement("svg", {
                  attrs: {
                    fill: "currentColor",
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 0 20 20"
                  },
                  class: this.getElementCssClass("closeIcon")
                }, [
                  createElement("path", {
                    attrs: {
                      "clip-rule": "evenodd",
                      "fill-rule": "evenodd",
                      d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                    }
                  })
                ])
              ]));
            }
            if (!!this.$slots.header || this.header !== void 0) {
              childs.push(createElement("div", {
                ref: "header",
                class: this.getElementCssClass("header")
              }, this.$slots.header || this.header));
            }
            childs.push(createElement("div", {
              ref: "body",
              class: this.getElementCssClass("body")
            }, this.$slots.default));
            if (!!this.$slots.footer || this.footer !== void 0) {
              childs.push(createElement("div", {
                ref: "footer",
                class: this.getElementCssClass("footer")
              }, this.$slots.footer || this.footer));
            }
            return childs;
          },
          clickHandler(e) {
            if (e.target === this.$refs.overlay) {
              this.outsideClick();
            }
          },
          keyupHandler(e) {
            if (e.keyCode === Key$1.ESC && this.escToClose) {
              this.hide();
            }
          },
          beforeOpen() {
            this.$emit("before-open", { params: this.params, cancel: this.cancel });
          },
          opened() {
            this.$emit("opened", { params: this.params });
            this.prepareDomForModal();
          },
          beforeClose() {
            if (this.disableBodyScroll) {
              const overlay = this.getOverlay();
              if (overlay) {
                overlay.focus();
                bodyScrollLock.enableBodyScroll(overlay);
              }
            }
            this.$emit("before-close", { cancel: this.cancel });
          },
          closed() {
            this.$emit("closed");
          },
          prepareDomForModal() {
            const overlay = this.getOverlay();
            if (!overlay) {
              return;
            }
            if (this.disableBodyScroll) {
              bodyScrollLock.disableBodyScroll(overlay, this.bodyScrollLockOptions);
            }
            if (this.focusOnOpen) {
              overlay.focus();
            }
          },
          hide() {
            this.beforeClose();
            if (!this.preventAction) {
              this.modalShow = false;
            } else {
              this.preventAction = false;
            }
          },
          show(params = void 0) {
            this.params = params;
            this.beforeOpen();
            if (!this.preventAction) {
              this.overlayShow = true;
            } else {
              this.preventAction = false;
            }
          },
          cancel() {
            this.preventAction = true;
          },
          outsideClick() {
            if (this.clickToClose) {
              this.hide();
            }
          },
          getOverlay() {
            return this.$refs.overlay;
          }
        }
      });
      const TDropdown = Component.extend({
        name: "TDropdown",
        props: {
          text: {
            type: String,
            default: ""
          },
          disabled: {
            type: Boolean,
            default: void 0
          },
          tagName: {
            type: String,
            default: "div"
          },
          dropdownWrapperTagName: {
            type: String,
            default: "div"
          },
          dropdownTagName: {
            type: String,
            default: "div"
          },
          toggleOnFocus: {
            type: Boolean,
            default: false
          },
          toggleOnClick: {
            type: Boolean,
            default: true
          },
          toggleOnHover: {
            type: Boolean,
            default: false
          },
          hideOnLeaveTimeout: {
            type: Number,
            default: 250
          },
          show: {
            type: Boolean,
            default: false
          },
          classes: {
            type: Object,
            default() {
              return {
                button: "block px-4 py-2 text-white transition duration-100 ease-in-out bg-blue-500 border border-transparent rounded shadow-sm hover:bg-blue-600 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed",
                wrapper: "inline-flex flex-col",
                dropdownWrapper: "relative z-10",
                dropdown: "origin-top-left absolute left-0 w-56 rounded shadow bg-white mt-1",
                enterClass: "opacity-0 scale-95",
                enterActiveClass: "transition transform ease-out duration-100",
                enterToClass: "opacity-100 scale-100",
                leaveClass: "opacity-100 scale-100",
                leaveActiveClass: "transition transform ease-in duration-75",
                leaveToClass: "opacity-0 scale-95"
              };
            }
          }
        },
        data() {
          return {
            localShow: this.show,
            hasFocus: false,
            hideOnLeaveTimeoutHolder: null
          };
        },
        render(createElement) {
          const renderFun = this.render;
          return renderFun(createElement);
        },
        watch: {
          show(show) {
            this.localShow = show;
          },
          localShow(localShow) {
            this.$emit("update:show", localShow);
            if (localShow) {
              this.$emit("shown");
            } else {
              this.$emit("hidden");
            }
          }
        },
        methods: {
          render(createElement) {
            const defaultSlot = this.$scopedSlots.default ? this.$scopedSlots.default({
              hide: this.doHide,
              show: this.doShow,
              toggle: this.doToggle,
              blurHandler: this.blurHandler
            }) : null;
            const triggerSlot = this.$scopedSlots.trigger ? this.$scopedSlots.trigger({
              isShown: this.localShow,
              hide: this.doHide,
              hideIfFocusOutside: this.hideIfFocusOutside,
              show: this.doShow,
              toggle: this.doToggle,
              mousedownHandler: this.mousedownHandler,
              focusHandler: this.focusHandler,
              blurHandler: this.blurHandler,
              keydownHandler: this.keydownHandler,
              disabled: this.disabled
            }) : createElement("button", {
              ref: "button",
              attrs: {
                type: "button",
                disabled: this.disabled
              },
              class: this.getElementCssClass("button"),
              on: {
                keydown: this.keydownHandler,
                mousedown: this.mousedownHandler,
                focus: this.focusHandler,
                blur: this.blurHandler
              }
            }, this.$slots.button || this.text);
            const subElements = [
              triggerSlot,
              createElement("transition", {
                props: {
                  enterClass: this.getElementCssClass("enterClass"),
                  enterActiveClass: this.getElementCssClass("enterActiveClass"),
                  enterToClass: this.getElementCssClass("enterToClass"),
                  leaveClass: this.getElementCssClass("leaveClass"),
                  leaveActiveClass: this.getElementCssClass("leaveActiveClass"),
                  leaveToClass: this.getElementCssClass("leaveToClass")
                }
              }, this.localShow ? [
                createElement(this.dropdownWrapperTagName, {
                  ref: "dropdownWrapper",
                  class: this.getElementCssClass("dropdownWrapper"),
                  attrs: {
                    tabindex: -1
                  },
                  on: {
                    focus: this.focusHandler,
                    blur: this.blurHandler
                  }
                }, [
                  createElement(this.dropdownTagName, {
                    ref: "dropdown",
                    class: this.getElementCssClass("dropdown")
                  }, defaultSlot)
                ])
              ] : void 0)
            ];
            return createElement(this.tagName, {
              ref: "wrapper",
              class: this.getElementCssClass("wrapper"),
              on: {
                mouseover: this.mouseoverHandler,
                mouseleave: this.mouseleaveHandler
              }
            }, subElements);
          },
          blurEventTargetIsChild(e) {
            const blurredElement = e.relatedTarget;
            if (blurredElement) {
              const wrapper = this.$refs.wrapper;
              return wrapper.contains(blurredElement);
            }
            return false;
          },
          focusEventTargetIsChild(e) {
            const focusedElement = e.target;
            if (focusedElement) {
              const wrapper = this.$refs.wrapper;
              return wrapper.contains(focusedElement);
            }
            return false;
          },
          escapeHandler() {
            this.doHide();
          },
          mousedownHandler() {
            if (this.toggleOnClick) {
              this.doToggle();
            }
          },
          focusHandler(e) {
            if (!this.hasFocus && this.focusEventTargetIsChild(e)) {
              this.hasFocus = true;
              this.$emit("focus", e);
            }
            if (this.toggleOnFocus) {
              this.doShow();
            }
          },
          blurHandler(e) {
            if (this.hasFocus && !this.blurEventTargetIsChild(e)) {
              this.hasFocus = false;
              this.$emit("blur", e);
            }
            if (this.toggleOnFocus || this.toggleOnClick) {
              this.hideIfFocusOutside(e);
            }
          },
          keydownHandler(e) {
            if ([Key$1.ENTER, Key$1.SPACE].includes(e.keyCode)) {
              this.mousedownHandler();
            } else if (e.keyCode === Key$1.ESC) {
              this.escapeHandler();
            }
            this.$emit("keydown", e);
          },
          mouseleaveHandler() {
            if (!this.toggleOnHover) {
              return;
            }
            if (!this.hideOnLeaveTimeout) {
              this.doHide();
              return;
            }
            this.hideOnLeaveTimeoutHolder = setTimeout(() => {
              this.doHide();
              this.hideOnLeaveTimeoutHolder = null;
            }, this.hideOnLeaveTimeout);
          },
          mouseoverHandler() {
            if (!this.toggleOnHover) {
              return;
            }
            if (this.hideOnLeaveTimeout && this.hideOnLeaveTimeoutHolder) {
              clearTimeout(this.hideOnLeaveTimeoutHolder);
              this.hideOnLeaveTimeoutHolder = null;
            }
            this.doShow();
          },
          doHide() {
            this.localShow = false;
          },
          hideIfFocusOutside(e) {
            if (!(e instanceof Event)) {
              throw new Error("the method hideIfFocusOutside expects an instance of `Event` as parameter");
            }
            if (!this.blurEventTargetIsChild(e)) {
              this.doHide();
            }
          },
          doShow() {
            this.localShow = true;
          },
          doToggle() {
            if (this.localShow) {
              this.doHide();
            } else {
              this.doShow();
            }
          },
          blur() {
            const el = this.$refs.button;
            el.blur();
          },
          focus(options) {
            const el = this.$refs.button;
            el.focus(options);
          }
        }
      });
      const TPagination = Component.extend({
        name: "TPagination",
        props: {
          value: {
            type: Number,
            default: null
          },
          tagName: {
            type: String,
            default: "ul"
          },
          elementTagName: {
            type: String,
            default: "li"
          },
          disabled: {
            type: Boolean,
            default: false
          },
          perPage: {
            type: Number,
            default: 20,
            validator: (value) => value > 0
          },
          totalItems: {
            type: Number,
            default: 0,
            validator: (value) => value >= 0
          },
          limit: {
            type: Number,
            default: 5,
            validator: (value) => value >= 0
          },
          prevLabel: {
            type: String,
            default: "&lsaquo;"
          },
          nextLabel: {
            type: String,
            default: "&rsaquo;"
          },
          firstLabel: {
            type: String,
            default: "&laquo;"
          },
          lastLabel: {
            type: String,
            default: "&raquo;"
          },
          ellipsisLabel: {
            type: String,
            default: "&hellip;"
          },
          hideFirstLastControls: {
            type: Boolean,
            default: false
          },
          hidePrevNextControls: {
            type: Boolean,
            default: false
          },
          hideEllipsis: {
            type: Boolean,
            default: false
          },
          classes: {
            type: Object,
            default() {
              return {
                wrapper: "table border-collapse text-center bg-white mx-auto shadow-sm",
                element: "w-8 h-8 border border-gray-200 table-cell hover:border-blue-100",
                activeElement: "w-8 h-8 border border-blue-500 table-cell hover:border-blue-600",
                disabledElement: "w-8 h-8 border border-gray-200 table-cell",
                ellipsisElement: "w-8 h-8 border border-gray-200 hidden md:table-cell",
                activeButton: "bg-blue-500 w-full h-full text-white hover:bg-blue-600 transition duration-100 ease-in-out focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
                disabledButton: "opacity-25 w-full h-full cursor-not-allowed transition duration-100 ease-in-out",
                button: "hover:bg-blue-100 w-full h-full transition duration-100 ease-in-out focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
                ellipsis: ""
              };
            }
          }
        },
        render(createElement) {
          const createComponentFunc = this.createComponent;
          return createComponentFunc(createElement);
        },
        data() {
          return {
            currentPage: this.value
          };
        },
        computed: {
          totalPages() {
            if (this.perPage <= 0) {
              return 0;
            }
            return Math.ceil(this.totalItems / this.perPage);
          },
          pageButtons() {
            const from1 = Number(this.currentPage) - Math.round(this.limit / 2) + 1;
            const from2 = this.totalPages + 1 - this.limit;
            const from = Math.max(Math.min(from1, from2), 1);
            const to = Math.min(from + this.limit - 1, this.totalPages);
            return range__default["default"](from, to + 1).map((page) => {
              if (!this.hideEllipsis && page === from && from > 1) {
                return "less";
              }
              if (!this.hideEllipsis && page === to && to < this.totalPages) {
                return "more";
              }
              return String(page);
            });
          },
          prevIsDisabled() {
            return this.disabled || this.currentPage === null || this.currentPage <= 1;
          },
          nextIsDisabled() {
            return this.disabled || this.currentPage === null || this.currentPage >= this.totalPages;
          }
        },
        watch: {
          value(value) {
            this.currentPage = value;
          },
          currentPage(currentPage) {
            this.$emit("input", currentPage);
            this.$emit("change", currentPage);
          }
        },
        methods: {
          createComponent(createElement) {
            const subElements = [];
            if (!this.hideFirstLastControls) {
              subElements.push(this.createControl(createElement, this.firstLabel, this.prevIsDisabled, false, this.goToFirstPage));
            }
            if (!this.hidePrevNextControls) {
              subElements.push(this.createControl(createElement, this.prevLabel, this.prevIsDisabled, false, this.goToPrevPage));
            }
            this.pageButtons.forEach((page) => {
              if (page === "less" || page === "more") {
                subElements.push(this.createControl(createElement, this.ellipsisLabel));
              } else {
                subElements.push(this.createControl(createElement, page, false, this.isPageActive(Number(page)), () => this.selectPage(Number(page))));
              }
            });
            if (!this.hidePrevNextControls) {
              subElements.push(this.createControl(createElement, this.nextLabel, this.nextIsDisabled, false, this.goToNextPage));
            }
            if (!this.hideFirstLastControls) {
              subElements.push(this.createControl(createElement, this.lastLabel, this.nextIsDisabled, false, this.goToLastPage));
            }
            return createElement(this.tagName, {
              class: this.getElementCssClass("wrapper")
            }, subElements);
          },
          createControl(createElement, text, disabled = false, active = false, clickHandler) {
            let className = "";
            if (!clickHandler) {
              className = this.getElementCssClass("ellipsisElement");
            } else if (disabled) {
              className = this.getElementCssClass("disabledElement");
            } else if (active) {
              className = this.getElementCssClass("activeElement");
            } else {
              className = this.getElementCssClass("element");
            }
            return createElement(this.elementTagName, {
              class: className
            }, [
              this.createControlButton(createElement, text, disabled, active, clickHandler)
            ]);
          },
          createControlButton(createElement, text, disabled = false, active = false, clickHandler) {
            if (!clickHandler) {
              return createElement("span", {
                class: this.getElementCssClass("ellipsis"),
                domProps: {
                  innerHTML: text
                }
              });
            }
            let className = "";
            const attrs = {};
            if (disabled) {
              className = this.getElementCssClass("disabledButton");
              attrs.disabled = true;
            } else if (active) {
              className = this.getElementCssClass("activeButton");
            } else {
              className = this.getElementCssClass("button");
            }
            return createElement("button", {
              class: className,
              on: {
                click: clickHandler
              },
              attrs,
              domProps: {
                disabled: disabled ? true : void 0,
                innerHTML: text
              }
            });
          },
          selectPage(page) {
            this.currentPage = page;
          },
          goToPrevPage() {
            this.currentPage = this.currentPage === null ? 1 : Math.max(this.currentPage - 1, 1);
          },
          goToNextPage() {
            this.currentPage = this.currentPage === null ? this.totalPages : Math.min(this.currentPage + 1, this.totalPages);
          },
          goToFirstPage() {
            this.currentPage = 1;
          },
          goToLastPage() {
            this.currentPage = this.totalPages;
          },
          isPageActive(page) {
            return page === this.currentPage;
          }
        }
      });
      const TTag = Component.extend({
        name: "TTag",
        props: {
          text: {
            type: String,
            default: void 0
          },
          tagName: {
            type: String,
            default: "div"
          }
        },
        render(createElement) {
          const renderFun = this.render;
          return renderFun(createElement);
        },
        methods: {
          render(createElement) {
            return createElement(this.tagName, {
              class: this.componentClass
            }, this.text === void 0 ? this.$slots.default : this.text);
          }
        }
      });
      const TRadioGroup = InputWithOptions.extend({
        name: "TRadioGroup",
        props: {
          groupWrapperTag: {
            type: String,
            default: "div"
          },
          wrapperTag: {
            type: String,
            default: "label"
          },
          inputWrapperTag: {
            type: String,
            default: "span"
          },
          labelTag: {
            type: String,
            default: "span"
          },
          fixedClasses: {
            type: Object,
            default() {
              return {};
            }
          },
          classes: {
            type: Object,
            default() {
              return {
                groupWrapper: "flex flex-col",
                label: "",
                input: "text-blue-500 transition duration-100 ease-in-out border-gray-300 shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 focus:ring-offset-0 disabled:opacity-50 disabled:cursor-not-allowed",
                inputWrapper: "inline-flex",
                wrapper: "inline-flex items-center space-x-2"
              };
            }
          }
        },
        data() {
          return {
            localValue: this.value
          };
        },
        watch: {
          localValue(localValue) {
            this.$emit("input", localValue);
            this.$emit("change", localValue);
          },
          value(value) {
            this.localValue = value;
          }
        },
        render(createElement) {
          const createRadioGroupFunc = this.createRadioGroup;
          return createRadioGroupFunc(createElement);
        },
        methods: {
          createRadioGroup(createElement) {
            return createElement(this.groupWrapperTag, {
              ref: "wrapper",
              class: this.getElementCssClass("groupWrapper")
            }, this.createRadioOptions(createElement));
          },
          createRadioOptions(createElement) {
            const options = this.normalizedOptions;
            return options.map((option, index) => this.createRadioOption(createElement, option, index));
          },
          createRadioOption(createElement, option, index) {
            return createElement(TRadio, {
              props: {
                id: this.buildId(option, index),
                name: this.name,
                tabindex: this.tabindex,
                disabled: this.disabled,
                autofocus: this.autofocus,
                required: this.required,
                model: this.localValue,
                label: option.text,
                wrapped: true,
                value: option.value,
                checked: this.value === option.value,
                variant: this.variant,
                classes: this.classes,
                fixedClasses: this.fixedClasses,
                variants: this.variants,
                wrapperTag: this.wrapperTag,
                inputWrapperTag: this.inputWrapperTag,
                labelTag: this.labelTag
              },
              scopedSlots: {
                default: this.$scopedSlots.default
              },
              on: {
                blur: this.blurHandler,
                focus: this.focusHandler,
                input: (value) => {
                  if (isEqual__default["default"](value, option.value)) {
                    this.inputHandler(option.value);
                  }
                }
              }
            });
          },
          buildId(option, index) {
            const parts = [];
            if (this.id) {
              parts.push(this.id);
            } else if (this.name) {
              parts.push(this.name);
            }
            if (["string", "number"].includes(typeof option.value)) {
              parts.push(kebabCase__default["default"](String(option.value)));
            } else {
              parts.push(index);
            }
            return parts.join("-");
          },
          inputHandler(value) {
            this.$emit("input", value);
          },
          blurHandler(e) {
            this.$emit("blur", e);
          },
          focusHandler(e) {
            this.$emit("focus", e);
          }
        }
      });
      const TCheckboxGroup = InputWithOptions.extend({
        name: "TCheckboxGroup",
        props: {
          groupWrapperTag: {
            type: String,
            default: "div"
          },
          wrapperTag: {
            type: String,
            default: "label"
          },
          inputWrapperTag: {
            type: String,
            default: "span"
          },
          labelTag: {
            type: String,
            default: "span"
          },
          value: {
            type: Array,
            default() {
              return [];
            }
          },
          fixedClasses: {
            type: Object,
            default() {
              return {};
            }
          },
          classes: {
            type: Object,
            default() {
              return {
                groupWrapper: "flex flex-col",
                label: "",
                input: "text-blue-500 transition duration-100 ease-in-out border-gray-300 rounded shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 focus:ring-offset-0  disabled:opacity-50 disabled:cursor-not-allowed",
                inputWrapper: "inline-flex",
                wrapper: "inline-flex items-center space-x-2"
              };
            }
          }
        },
        data() {
          return {
            localValue: this.value
          };
        },
        watch: {
          localValue(localValue) {
            this.$emit("input", localValue);
            this.$emit("change", localValue);
          },
          value(value) {
            this.localValue = value;
          }
        },
        render(createElement) {
          const createRadioGroupFunc = this.createRadioGroup;
          return createRadioGroupFunc(createElement);
        },
        methods: {
          createRadioGroup(createElement) {
            return createElement(this.groupWrapperTag, {
              ref: "wrapper",
              class: this.getElementCssClass("groupWrapper")
            }, this.createRadioOptions(createElement));
          },
          createRadioOptions(createElement) {
            const options = this.normalizedOptions;
            return options.map((option, index) => this.createRadioOption(createElement, option, index));
          },
          createRadioOption(createElement, option, index) {
            return createElement(TCheckbox, {
              props: {
                id: this.buildId(option, index),
                name: this.name,
                tabindex: this.tabindex,
                disabled: this.disabled,
                autofocus: this.autofocus,
                required: this.required,
                model: this.localValue,
                label: option.text,
                wrapped: true,
                value: option.value,
                checked: this.value === option.value,
                variant: this.variant,
                classes: this.classes,
                fixedClasses: this.fixedClasses,
                variants: this.variants,
                wrapperTag: this.wrapperTag,
                inputWrapperTag: this.inputWrapperTag,
                labelTag: this.labelTag
              },
              scopedSlots: {
                default: this.$scopedSlots.default
              },
              on: {
                blur: this.blurHandler,
                focus: this.focusHandler,
                input: this.inputHandler
              }
            });
          },
          buildId(option, index) {
            const parts = [];
            if (this.id) {
              parts.push(this.id);
            } else if (this.name) {
              parts.push(this.name);
            }
            if (["string", "number"].includes(typeof option.value)) {
              parts.push(kebabCase__default["default"](String(option.value)));
            } else {
              parts.push(index);
            }
            return parts.join("-");
          },
          inputHandler(value) {
            this.localValue = value;
          },
          blurHandler(e) {
            this.$emit("blur", e);
          },
          focusHandler(e) {
            this.$emit("focus", e);
          }
        }
      });
      const TTable = Component.extend({
        name: "TTable",
        props: {
          data: {
            type: Array,
            default() {
              return [];
            }
          },
          headers: {
            type: Array,
            default() {
              return [];
            }
          },
          footerData: {
            type: Array,
            default() {
              return [];
            }
          },
          hideHeader: {
            type: Boolean,
            default: false
          },
          showFooter: {
            type: Boolean,
            default: false
          },
          responsive: {
            type: Boolean,
            default: false
          },
          responsiveBreakpoint: {
            type: Number,
            default: 768
          },
          classes: {
            type: Object,
            default: () => ({
              table: "min-w-full divide-y divide-gray-100 shadow-sm border-gray-200 border",
              thead: "",
              theadTr: "",
              theadTh: "px-3 py-2 font-semibold text-left bg-gray-100 border-b",
              tbody: "bg-white divide-y divide-gray-100",
              tr: "",
              td: "px-3 py-2 whitespace-no-wrap",
              tfoot: "",
              tfootTr: "",
              tfootTd: ""
            })
          }
        },
        data() {
          return {
            ready: !this.responsive,
            windowWidth: null
          };
        },
        computed: {
          renderResponsive() {
            const { windowWidth } = this;
            return this.responsive && windowWidth && windowWidth < this.responsiveBreakpoint;
          },
          normalizedHeaders() {
            return this.headers.map((header) => {
              if (typeof header === "string") {
                return {
                  text: header
                };
              }
              return header;
            });
          },
          normalizedFooterData() {
            return this.footerData.map((footer) => {
              if (typeof footer === "string") {
                return {
                  text: footer
                };
              }
              return footer;
            });
          },
          headersValues() {
            return this.headers.filter((h) => h.value).map((h) => h.value);
          },
          showHeader() {
            return !this.hideHeader;
          }
        },
        mounted() {
          if (this.responsive) {
            this.windowWidth = window.innerWidth;
            this.ready = true;
            window.addEventListener("resize", this.resizeListener);
          }
        },
        beforeDestroy() {
          if (this.responsive) {
            window.removeEventListener("resize", this.resizeListener);
          }
        },
        render(createElement) {
          const renderFun = this.renderTable;
          return renderFun(createElement);
        },
        methods: {
          resizeListener() {
            this.windowWidth = window.innerWidth;
          },
          renderTable(createElement) {
            if (!this.ready) {
              return createElement();
            }
            const childElements = [];
            if (!this.renderResponsive) {
              childElements.push(this.renderThead(createElement));
            }
            childElements.push(this.renderTbody(createElement));
            if (this.showFooter || this.$scopedSlots.tfoot) {
              childElements.push(this.renderTfoot(createElement));
            }
            return createElement("table", {
              ref: "table",
              class: this.getElementCssClass("table")
            }, childElements);
          },
          renderThead(createElement) {
            const trClass = this.getElementCssClass("theadTr");
            const thClass = this.getElementCssClass("theadTh");
            const theadClass = this.getElementCssClass("thead");
            if (this.$scopedSlots.thead) {
              const thead = this.$scopedSlots.thead({
                theadClass,
                trClass,
                thClass,
                data: this.normalizedHeaders
              });
              if (thead) {
                return thead;
              }
            }
            if (!this.showHeader) {
              return createElement();
            }
            const ths = this.normalizedHeaders.map((header) => createElement("th", {
              attrs: {
                id: header.id
              },
              class: header.className ? [thClass, header.className] : thClass
            }, header.text));
            return createElement("thead", {
              class: theadClass
            }, [
              createElement("tr", {
                class: trClass
              }, ths)
            ]);
          },
          renderTfoot(createElement) {
            const trClass = this.getElementCssClass("tfootTr");
            const tdClass = this.getElementCssClass("tfootTd");
            const tfootClass = this.getElementCssClass("tfoot");
            if (this.$scopedSlots.tfoot) {
              const tfoot = this.$scopedSlots.tfoot({
                tfootClass,
                trClass,
                tdClass,
                data: this.normalizedFooterData,
                headers: this.normalizedHeaders,
                renderResponsive: this.renderResponsive
              });
              if (tfoot) {
                return tfoot;
              }
            }
            const tds = this.normalizedFooterData.map((footer) => createElement("td", {
              attrs: {
                id: footer.id
              },
              class: footer.className ? [tdClass, footer.className] : tdClass
            }, footer.text));
            return createElement("tfoot", {
              class: tfootClass
            }, [
              createElement("tr", {
                class: trClass
              }, tds)
            ]);
          },
          renderTbody(createElement) {
            if (this.$scopedSlots.tbody) {
              const tbody = this.$scopedSlots.tbody({
                tbodyClass: this.getElementCssClass("tbody"),
                trClass: this.getElementCssClass("tr"),
                tdClass: this.getElementCssClass("td"),
                data: this.data,
                headers: this.normalizedHeaders,
                renderResponsive: this.renderResponsive
              });
              if (tbody) {
                return tbody;
              }
            }
            return createElement("tbody", {
              class: this.getElementCssClass("tbody")
            }, this.renderRows(createElement));
          },
          renderRows(createElement) {
            return this.data.map((row, rowIndex) => {
              if (this.$scopedSlots.row) {
                const tableRow = this.$scopedSlots.row({
                  rowIndex,
                  row,
                  trClass: this.getElementCssClass("tr"),
                  tdClass: this.getElementCssClass("td")
                });
                if (tableRow) {
                  return tableRow;
                }
              }
              return createElement("tr", {
                class: this.getElementCssClass("tr")
              }, this.renderCols(createElement, row, rowIndex));
            });
          },
          renderCols(createElement, row, rowIndex) {
            const columns = this.getRowColumns(row);
            if (typeof columns === "object") {
              return Object.keys(columns).map((columnIndex) => {
                const text = columns[columnIndex];
                return this.renderCol(createElement, text, rowIndex, columnIndex);
              });
            }
            return columns.map((text, columnIndex) => this.renderCol(createElement, text, rowIndex, columnIndex));
          },
          renderCol(createElement, text, rowIndex, columnIndex) {
            if (this.$scopedSlots.column) {
              const tableColumn = this.$scopedSlots.column({
                rowIndex,
                columnIndex,
                text,
                tdClass: this.getElementCssClass("td")
              });
              if (tableColumn) {
                return tableColumn;
              }
            }
            return createElement("td", {
              class: this.getElementCssClass("td")
            }, text);
          },
          getRowColumns(row) {
            if (!this.headersValues.length) {
              return row;
            }
            if (typeof row === "object") {
              return pick__default["default"](row, this.headersValues);
            }
            return {};
          }
        }
      });
      const English = {
        weekdays: {
          shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          longhand: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          longhand: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: (nth) => {
          const s = nth % 100;
          if (s > 3 && s < 21)
            return "th";
          switch (s % 10) {
            case 1:
              return "st";
            case 2:
              return "nd";
            case 3:
              return "rd";
            default:
              return "th";
          }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year",
        monthAriaLabel: "Month",
        hourAriaLabel: "Hour",
        minuteAriaLabel: "Minute",
        time24hr: false,
        timeLabel: "Time",
        okLabel: "Ok"
      };
      const pad = (number, length = 2) => `000${number}`.slice(length * -1);
      const int = (bool) => bool === true ? 1 : 0;
      const doNothing = () => void 0;
      const monthToStr = (monthNumber, shorthand, locale) => locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
      const revFormat = {
        D: doNothing,
        F(dateObj, monthName, locale) {
          dateObj.setMonth(locale.months.longhand.indexOf(monthName));
        },
        G: (dateObj, hour) => {
          dateObj.setHours(parseFloat(hour));
        },
        H: (dateObj, hour) => {
          dateObj.setHours(parseFloat(hour));
        },
        J: (dateObj, day) => {
          dateObj.setDate(parseFloat(day));
        },
        K: (dateObj, amPM, locale) => {
          dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
        },
        M(dateObj, shortMonth, locale) {
          dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
        },
        S: (dateObj, seconds) => {
          dateObj.setSeconds(parseFloat(seconds));
        },
        U: (_, unixSeconds) => new Date(parseFloat(unixSeconds) * 1e3),
        W(dateObj, weekNum, locale) {
          const weekNumber = parseInt(weekNum, 10);
          const date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
          date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
          return date;
        },
        Y: (dateObj, year) => {
          dateObj.setFullYear(parseFloat(year));
        },
        Z: (_, ISODate) => new Date(ISODate),
        d: (dateObj, day) => {
          dateObj.setDate(parseFloat(day));
        },
        h: (dateObj, hour) => {
          dateObj.setHours(parseFloat(hour));
        },
        i: (dateObj, minutes) => {
          dateObj.setMinutes(parseFloat(minutes));
        },
        j: (dateObj, day) => {
          dateObj.setDate(parseFloat(day));
        },
        l: doNothing,
        m: (dateObj, month) => {
          dateObj.setMonth(parseFloat(month) - 1);
        },
        n: (dateObj, month) => {
          dateObj.setMonth(parseFloat(month) - 1);
        },
        s: (dateObj, seconds) => {
          dateObj.setSeconds(parseFloat(seconds));
        },
        u: (_, unixMillSeconds) => new Date(parseFloat(unixMillSeconds)),
        w: doNothing,
        y: (dateObj, year) => {
          dateObj.setFullYear(2e3 + parseFloat(year));
        }
      };
      const tokenRegex = {
        D: "(\\w+)",
        F: "(\\w+)",
        G: "(\\d\\d|\\d)",
        H: "(\\d\\d|\\d)",
        J: "(\\d\\d|\\d)\\w+",
        K: "",
        M: "(\\w+)",
        S: "(\\d\\d|\\d)",
        U: "(.+)",
        W: "(\\d\\d|\\d)",
        Y: "(\\d{4})",
        Z: "(.+)",
        d: "(\\d\\d|\\d)",
        h: "(\\d\\d|\\d)",
        i: "(\\d\\d|\\d)",
        j: "(\\d\\d|\\d)",
        l: "(\\w+)",
        m: "(\\d\\d|\\d)",
        n: "(\\d\\d|\\d)",
        s: "(\\d\\d|\\d)",
        u: "(.+)",
        w: "(\\d\\d|\\d)",
        y: "(\\d{2})"
      };
      const formats = {
        Z: (date) => date.toISOString(),
        D(date, locale) {
          return locale.weekdays.shorthand[formats.w(date, locale)];
        },
        F(date, locale) {
          return monthToStr(formats.n(date, locale) - 1, false, locale);
        },
        G(date, locale) {
          return pad(formats.h(date, locale));
        },
        H: (date) => pad(date.getHours()),
        J(date, locale) {
          return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
        },
        K: (date, locale) => locale.amPM[int(date.getHours() > 11)],
        M(date, locale) {
          return monthToStr(date.getMonth(), true, locale);
        },
        S: (date) => pad(date.getSeconds()),
        U: (date) => date.getTime() / 1e3,
        W(givenDate) {
          const date = new Date(givenDate.getTime());
          date.setHours(0, 0, 0, 0);
          date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
          const week1 = new Date(date.getFullYear(), 0, 4);
          return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
        },
        Y: (date) => pad(date.getFullYear(), 4),
        d: (date) => pad(date.getDate()),
        h: (date) => date.getHours() % 12 ? date.getHours() % 12 : 12,
        i: (date) => pad(date.getMinutes()),
        j: (date) => date.getDate(),
        l(date, locale) {
          return locale.weekdays.longhand[date.getDay()];
        },
        m: (date) => pad(date.getMonth() + 1),
        n: (date) => date.getMonth() + 1,
        s: (date) => date.getSeconds(),
        u: (date) => date.getTime(),
        w: (date) => date.getDay(),
        y: (date) => String(date.getFullYear()).substring(2)
      };
      const formatDate = (dateObj, format, customLocale) => {
        if (!dateObj) {
          return "";
        }
        const locale = customLocale || English;
        return format.split("").map((char, i, arr) => {
          if (formats[char] && arr[i - 1] !== "\\") {
            return formats[char](dateObj, locale);
          }
          if (char !== "\\") {
            return char;
          }
          return "";
        }).join("");
      };
      const parseDate = (date, format = "Y-m-d H:i:S", timeless, customLocale) => {
        if (date !== 0 && !date) {
          return void 0;
        }
        const locale = customLocale || English;
        const localeTokenRegex = Object.assign({}, tokenRegex);
        localeTokenRegex.K = `(${locale.amPM[0]}|${locale.amPM[1]}|${locale.amPM[0].toLowerCase()}|${locale.amPM[1].toLowerCase()})`;
        let parsedDate;
        const dateOrig = date;
        if (date instanceof Date) {
          parsedDate = new Date(date.getTime());
        } else if (typeof date !== "string" && date.toFixed !== void 0) {
          parsedDate = new Date(date);
        } else if (typeof date === "string") {
          const datestr = String(date).trim();
          if (datestr === "today") {
            parsedDate = new Date();
            timeless = true;
          } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
            parsedDate = new Date(date);
          } else {
            parsedDate = new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0);
            let matched;
            const ops = [];
            for (let i = 0, matchIndex = 0, regexStr = ""; i < format.length; i += 1) {
              const token2 = format[i];
              const isBackSlash = token2 === "\\";
              const escaped = format[i - 1] === "\\" || isBackSlash;
              if (localeTokenRegex[token2] && !escaped) {
                regexStr += localeTokenRegex[token2];
                const match = new RegExp(regexStr).exec(date);
                if (match) {
                  matched = true;
                  ops[token2 !== "Y" ? "push" : "unshift"]({
                    fn: revFormat[token2],
                    val: match[matchIndex += 1]
                  });
                }
              } else if (!isBackSlash) {
                regexStr += ".";
              }
              ops.forEach((op) => {
                const { fn } = op;
                const { val } = op;
                parsedDate = fn(parsedDate, String(val), locale) || parsedDate;
              });
            }
            parsedDate = matched ? parsedDate : void 0;
          }
        }
        if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
          throw new Error(`Invalid date provided: ${dateOrig}`);
        }
        if (timeless === true) {
          parsedDate.setHours(0, 0, 0, 0);
        }
        return parsedDate;
      };
      function compareDates(date1, date2, timeless = true) {
        if (timeless !== false) {
          return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
        }
        return date1.getTime() - date2.getTime();
      }
      const extractLocaleFromProps = (localeName, locales, defaultLocale) => {
        const availableLocales = Object.keys(locales);
        const find = availableLocales.find((l) => l === localeName);
        const locale = find && locales[find] ? locales[find] : defaultLocale;
        return merge__default["default"](cloneDeep__default["default"](English), locale);
      };
      const buildDateParser = (locale, customDateParser) => (date, format = "Y-m-d H:i:S", timeless) => {
        if (customDateParser) {
          return customDateParser(date, format, timeless, locale);
        }
        return parseDate(date, format, timeless, locale);
      };
      const buildDateFormatter = (locale, customDateFormatter) => (date, format = "Y-m-d H:i:S") => {
        if (customDateFormatter) {
          return customDateFormatter(date, format, locale);
        }
        return formatDate(date, format, locale);
      };
      function isSameMonth(date1, date2) {
        return !!date1 && !!date2 && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();
      }
      function isSameDay(date1, date2) {
        return isSameMonth(date1, date2) && (date1 === null || date1 === void 0 ? void 0 : date1.getDate()) === (date2 === null || date2 === void 0 ? void 0 : date2.getDate());
      }
      function dayIsPartOfTheConditions(day, condition, dateParser, dateFormat) {
        if (!day) {
          return false;
        }
        if (typeof condition === "function") {
          return condition(day);
        }
        if (typeof condition === "string" || condition instanceof String) {
          const disabledDate = dateParser(condition, dateFormat);
          return isSameDay(disabledDate, day);
        }
        if (condition instanceof Date) {
          return isSameDay(condition, day);
        }
        if (Array.isArray(condition)) {
          return condition.some((c) => dayIsPartOfTheConditions(day, c, dateParser, dateFormat));
        }
        return false;
      }
      function dateIsOutOfRange(date, min, max, dateParser = null, dateFormat = null) {
        let minDate;
        if (typeof min === "string" || min instanceof String) {
          if (!dateParser) {
            throw new Error("strings needs a date parser");
          }
          if (!dateFormat) {
            throw new Error("strings needs a date format");
          }
          minDate = dateParser(min, dateFormat);
        } else {
          minDate = min;
        }
        let maxDate;
        if (typeof max === "string" || max instanceof String) {
          if (!dateParser) {
            throw new Error("strings needs a date parser");
          }
          if (!dateFormat) {
            throw new Error("strings needs a date format");
          }
          maxDate = dateParser(max, dateFormat);
        } else {
          maxDate = max;
        }
        const time = date.getTime();
        if (minDate && maxDate) {
          return time < minDate.getTime() || time > maxDate.getTime();
        }
        if (minDate) {
          return time < minDate.getTime();
        }
        if (maxDate) {
          return time > maxDate.getTime();
        }
        return false;
      }
      function addDays(date, amount = 1) {
        const result = new Date(date);
        result.setDate(result.getDate() + amount);
        return result;
      }
      function addMonths(date, amount = 1) {
        let newDate = new Date(date.valueOf());
        newDate.setMonth(date.getMonth() + amount);
        if (newDate.getDate() !== date.getDate()) {
          newDate = new Date(newDate.getFullYear(), newDate.getMonth(), 0);
        }
        return newDate;
      }
      function addYears(date, amount = 1) {
        let newDate = new Date(date.valueOf());
        newDate.setFullYear(date.getFullYear() + amount);
        if (newDate.getDate() !== date.getDate()) {
          newDate = new Date(newDate.getFullYear(), newDate.getMonth(), 0);
        }
        return newDate;
      }
      function lastDayOfMonth(date) {
        return new Date(date.getFullYear(), date.getMonth() + 1, 0);
      }
      const getYearsRange = (date, yearsPerView) => {
        const currentYear = date.getFullYear();
        const from = currentYear - Math.floor(currentYear % yearsPerView);
        const to = from + yearsPerView - 1;
        return [from, to];
      };
      var CalendarView;
      (function(CalendarView2) {
        CalendarView2["Day"] = "day";
        CalendarView2["Month"] = "month";
        CalendarView2["Year"] = "year";
      })(CalendarView || (CalendarView = {}));
      const TDatepickerNavigator = Vue__default["default"].extend({
        name: "TDatepickerNavigator",
        props: {
          getElementCssClass: {
            type: Function,
            required: true
          },
          value: {
            type: Date,
            default: null
          },
          showSelector: {
            type: Boolean,
            default: true
          },
          currentView: {
            type: String,
            default: CalendarView.Day,
            validator(value) {
              return [CalendarView.Day, CalendarView.Month, CalendarView.Year].includes(value);
            }
          },
          parse: {
            type: Function,
            required: true
          },
          formatNative: {
            type: Function,
            required: true
          },
          dateFormat: {
            type: String,
            required: true
          },
          yearsPerView: {
            type: Number,
            required: true
          },
          maxDate: {
            type: [Date, String],
            default: void 0
          },
          minDate: {
            type: [Date, String],
            default: void 0
          },
          locale: {
            type: Object,
            required: true
          }
        },
        data() {
          return {
            localValue: new Date(this.value.valueOf())
          };
        },
        computed: {
          isDayView() {
            return this.currentView === CalendarView.Day;
          },
          isYearView() {
            return this.currentView === CalendarView.Year;
          },
          isMonthView() {
            return this.currentView === CalendarView.Month;
          },
          nextDate() {
            return this.getNextDate();
          },
          prevDate() {
            return this.getPrevDate();
          },
          prevButtonIsDisabled() {
            return !this.prevDate;
          },
          nextButtonIsDisabled() {
            return !this.nextDate;
          },
          nextButtonAriaLabel() {
            if (this.isDayView) {
              return `Next ${this.locale.yearAriaLabel}`;
            }
            return `Next ${this.locale.yearAriaLabel}`;
          },
          prevButtonAriaLabel() {
            if (this.isDayView) {
              return `Prev ${this.locale.yearAriaLabel}`;
            }
            return `Prev ${this.locale.yearAriaLabel}`;
          }
        },
        watch: {
          value(value) {
            this.localValue = new Date(value.valueOf());
          }
        },
        methods: {
          getNextDate() {
            let nextDate;
            if (this.currentView === CalendarView.Day) {
              nextDate = this.getNextMonth();
            } else if (this.currentView === CalendarView.Month) {
              nextDate = this.getNextYear();
            } else if (this.currentView === CalendarView.Year) {
              nextDate = this.getNextYearGroup();
            }
            return nextDate;
          },
          getPrevDate() {
            let prevDate;
            if (this.currentView === CalendarView.Day) {
              prevDate = this.getPrevMonth();
            } else if (this.currentView === CalendarView.Month) {
              prevDate = this.getPrevYear();
            } else if (this.currentView === CalendarView.Year) {
              prevDate = this.getPrevYearGroup();
            }
            return prevDate;
          },
          inputHandler(newDate) {
            this.$emit("input", newDate);
          },
          clickHandler() {
            if (this.currentView === CalendarView.Day) {
              this.$emit("update-view", CalendarView.Month);
            } else if (this.currentView === CalendarView.Month) {
              this.$emit("update-view", CalendarView.Year);
            } else if (this.currentView === CalendarView.Year) {
              this.$emit("update-view", CalendarView.Day);
            }
          },
          next() {
            if (this.nextDate) {
              this.inputHandler(this.nextDate);
            }
          },
          prev() {
            if (this.prevDate) {
              this.inputHandler(this.prevDate);
            }
          },
          getPrevMonth() {
            const prevMonth = addMonths(this.localValue, -1);
            const dateParser = this.parse;
            if (!dateIsOutOfRange(prevMonth, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
              return prevMonth;
            }
            let day = prevMonth.getDate();
            let dateToTry = prevMonth;
            let validDate;
            day = prevMonth.getDate();
            const lastDay = lastDayOfMonth(prevMonth).getDate();
            do {
              dateToTry = addDays(dateToTry, 1);
              day += 1;
              if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                validDate = dateToTry;
              }
            } while (day <= lastDay && !validDate);
            if (!validDate) {
              day = prevMonth.getDate();
              do {
                dateToTry = addDays(dateToTry, -1);
                day -= 1;
                if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                  validDate = dateToTry;
                }
              } while (day >= 1 && !validDate);
            }
            return validDate;
          },
          getNextMonth() {
            const nextMonth = addMonths(this.localValue, 1);
            const dateParser = this.parse;
            if (!dateIsOutOfRange(nextMonth, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
              return nextMonth;
            }
            let day = nextMonth.getDate();
            let dateToTry = nextMonth;
            let validDate;
            do {
              dateToTry = addDays(dateToTry, -1);
              day -= 1;
              if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                validDate = dateToTry;
              }
            } while (day >= 1 && !validDate);
            if (!validDate) {
              day = nextMonth.getDate();
              const lastDay = lastDayOfMonth(nextMonth).getDate();
              do {
                dateToTry = addDays(dateToTry, 1);
                day += 1;
                if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                  validDate = dateToTry;
                }
              } while (day <= lastDay && !validDate);
            }
            return validDate;
          },
          getPrevYear() {
            const prevYear = addYears(this.localValue, -1);
            const dateParser = this.parse;
            if (!dateIsOutOfRange(prevYear, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
              return prevYear;
            }
            let validDate;
            let dateToTry = prevYear;
            const year = prevYear.getFullYear();
            do {
              dateToTry = addDays(dateToTry, 1);
              if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                validDate = dateToTry;
              }
            } while (dateToTry.getFullYear() === year && !validDate);
            if (!validDate) {
              do {
                dateToTry = addDays(dateToTry, -1);
                if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                  validDate = dateToTry;
                }
              } while (dateToTry.getFullYear() === year && !validDate);
            }
            return validDate;
          },
          getNextYear() {
            const nextYear = addYears(this.localValue, 1);
            const dateParser = this.parse;
            if (!dateIsOutOfRange(nextYear, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
              return nextYear;
            }
            let validDate;
            let dateToTry = nextYear;
            const year = nextYear.getFullYear();
            do {
              dateToTry = addDays(dateToTry, -1);
              if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                validDate = dateToTry;
              }
            } while (dateToTry.getFullYear() === year && !validDate);
            if (!validDate) {
              do {
                dateToTry = addDays(dateToTry, 1);
                if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                  validDate = dateToTry;
                }
              } while (dateToTry.getFullYear() === year && !validDate);
            }
            return validDate;
          },
          getPrevYearGroup() {
            const prevYear = addYears(this.localValue, -this.yearsPerView);
            const dateParser = this.parse;
            if (!dateIsOutOfRange(prevYear, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
              return prevYear;
            }
            let validDate;
            let dateToTry = prevYear;
            const year = prevYear.getFullYear();
            do {
              dateToTry = addDays(dateToTry, this.yearsPerView);
              if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                validDate = dateToTry;
              }
            } while (dateToTry.getFullYear() === year && !validDate);
            if (!validDate) {
              do {
                dateToTry = addDays(dateToTry, -this.yearsPerView);
                if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                  validDate = dateToTry;
                }
              } while (dateToTry.getFullYear() === year && !validDate);
            }
            return validDate;
          },
          getNextYearGroup() {
            const nextYear = addYears(this.localValue, this.yearsPerView);
            const dateParser = this.parse;
            if (!dateIsOutOfRange(nextYear, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
              return nextYear;
            }
            let validDate;
            let dateToTry = nextYear;
            const year = nextYear.getFullYear();
            do {
              dateToTry = addDays(dateToTry, -this.yearsPerView);
              if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                validDate = dateToTry;
              }
            } while (dateToTry.getFullYear() === year && !validDate);
            if (!validDate) {
              do {
                dateToTry = addDays(dateToTry, this.yearsPerView);
                if (!dateIsOutOfRange(dateToTry, this.minDate, this.maxDate, dateParser, this.dateFormat)) {
                  validDate = dateToTry;
                }
              } while (dateToTry.getFullYear() === year && !validDate);
            }
            return validDate;
          }
        },
        render(createElement) {
          const subElements = [];
          if (this.showSelector) {
            const buttonElements = [];
            if (this.currentView === CalendarView.Day) {
              buttonElements.push(createElement("span", {
                class: this.getElementCssClass("navigatorViewButtonMonthName")
              }, this.formatNative(this.localValue, "F")));
            }
            if (this.currentView === CalendarView.Month || this.currentView === CalendarView.Day) {
              buttonElements.push(createElement("span", {
                class: this.getElementCssClass("navigatorViewButtonYear")
              }, this.formatNative(this.localValue, "Y")));
            }
            if (this.currentView !== CalendarView.Year) {
              buttonElements.push(createElement("svg", {
                attrs: {
                  fill: "currentColor",
                  xmlns: "http://www.w3.org/2000/svg",
                  viewBox: "0 0 20 20"
                },
                class: this.getElementCssClass("navigatorViewButtonIcon")
              }, [
                createElement("polygon", {
                  attrs: {
                    points: "12.9497475 10.7071068 13.6568542 10 8 4.34314575 6.58578644 5.75735931 10.8284271 10 6.58578644 14.2426407 8 15.6568542 12.9497475 10.7071068"
                  }
                })
              ]));
            } else {
              buttonElements.push(createElement("svg", {
                attrs: {
                  fill: "currentColor",
                  xmlns: "http://www.w3.org/2000/svg",
                  viewBox: "0 0 20 20"
                },
                class: this.getElementCssClass("navigatorViewButtonBackIcon")
              }, [
                createElement("polygon", {
                  attrs: {
                    points: "7.05025253 9.29289322 6.34314575 10 12 15.6568542 13.4142136 14.2426407 9.17157288 10 13.4142136 5.75735931 12 4.34314575"
                  }
                })
              ]));
              buttonElements.push(createElement("span", {
                class: this.getElementCssClass("navigatorViewButtonYearRange")
              }, getYearsRange(this.localValue, this.yearsPerView).join(" - ")));
            }
            subElements.push(createElement("button", {
              attrs: {
                type: "button",
                class: this.getElementCssClass("navigatorViewButton"),
                tabindex: -1
              },
              on: {
                click: this.clickHandler
              }
            }, buttonElements));
          } else {
            subElements.push(createElement("span", {
              attrs: {
                class: this.getElementCssClass("navigatorLabel")
              }
            }, [
              createElement("span", {
                class: this.getElementCssClass("navigatorLabelMonth")
              }, this.formatNative(this.localValue, "F")),
              createElement("span", {
                class: this.getElementCssClass("navigatorLabelYear")
              }, this.formatNative(this.localValue, "Y"))
            ]));
          }
          if (this.showSelector) {
            subElements.push(createElement("button", {
              ref: "prev",
              attrs: {
                "aria-label": this.prevButtonAriaLabel,
                type: "button",
                class: this.getElementCssClass("navigatorPrevButton"),
                tabindex: -1,
                disabled: this.prevButtonIsDisabled ? true : void 0
              },
              on: {
                click: this.prev
              }
            }, [
              createElement("svg", {
                attrs: {
                  fill: "none",
                  viewBox: "0 0 24 24",
                  stroke: "currentColor"
                },
                class: this.getElementCssClass("navigatorPrevButtonIcon")
              }, [
                createElement("path", {
                  attrs: {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": 2,
                    d: "M15 19l-7-7 7-7"
                  }
                })
              ])
            ]));
            subElements.push(createElement("button", {
              ref: "next",
              attrs: {
                "aria-label": this.nextButtonAriaLabel,
                type: "button",
                class: this.getElementCssClass("navigatorNextButton"),
                tabindex: -1,
                disabled: this.nextButtonIsDisabled ? true : void 0
              },
              on: {
                click: this.next
              }
            }, [
              createElement("svg", {
                attrs: {
                  fill: "none",
                  viewBox: "0 0 24 24",
                  stroke: "currentColor"
                },
                class: this.getElementCssClass("navigatorNextButtonIcon")
              }, [
                createElement("path", {
                  attrs: {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": 2,
                    d: "M9 5l7 7-7 7"
                  }
                })
              ])
            ]));
          }
          return createElement("div", {
            class: this.getElementCssClass("navigator")
          }, subElements);
        }
      });
      const TDatepickerTrigger = Vue__default["default"].extend({
        name: "TDatepickerTrigger",
        props: {
          id: {
            type: String,
            default: void 0
          },
          name: {
            type: String,
            default: void 0
          },
          disabled: {
            type: Boolean,
            default: void 0
          },
          readonly: {
            type: Boolean,
            default: void 0
          },
          autofocus: {
            type: Boolean,
            default: void 0
          },
          required: {
            type: Boolean,
            default: void 0
          },
          tabindex: {
            type: [String, Number],
            default: void 0
          },
          inputName: {
            type: String,
            default: void 0
          },
          placeholder: {
            type: String,
            default: void 0
          },
          show: {
            type: Function,
            default: void 0
          },
          hideIfFocusOutside: {
            type: Function,
            default: void 0
          },
          conjunction: {
            type: String,
            required: true
          },
          multiple: {
            type: Boolean,
            required: true
          },
          range: {
            type: Boolean,
            required: true
          },
          clearable: {
            type: Boolean,
            required: true
          },
          locale: {
            type: Object,
            required: true
          },
          userFormatedDate: {
            type: [String, Array],
            required: true
          },
          formatedDate: {
            type: [String, Array],
            required: true
          },
          value: {
            type: [Date, Array],
            default: null
          },
          activeDate: {
            type: Date,
            required: true
          },
          getElementCssClass: {
            type: Function,
            required: true
          },
          hasFocus: {
            type: Boolean,
            required: true
          }
        },
        computed: {
          hasValue() {
            if (Array.isArray(this.value)) {
              return this.value.length > 0;
            }
            return !!this.value;
          }
        },
        methods: {
          clearButtonClickHandler(e) {
            this.$emit("clear", e);
          }
        },
        render(createElement) {
          const formattedDate = this.formatedDate;
          let formText = "";
          if (Array.isArray(this.userFormatedDate)) {
            const conjunction = this.range ? this.locale.rangeSeparator : this.conjunction;
            formText = this.userFormatedDate.join(conjunction);
          } else {
            formText = this.userFormatedDate;
          }
          const subElements = [
            createElement("input", {
              ref: "input",
              class: this.getElementCssClass("input"),
              attrs: {
                readonly: !this.hasFocus ? this.readonly : true,
                inputmode: "none",
                id: this.id,
                name: this.name,
                disabled: this.disabled,
                autocomplete: "off",
                autofocus: this.autofocus,
                type: "text",
                required: this.required,
                placeholder: this.placeholder,
                tabindex: this.tabindex,
                value: formText
              },
              on: {
                click: (e) => {
                  if (this.show) {
                    this.show();
                  }
                  this.$emit("click", e);
                },
                input: (e) => {
                  this.$emit("input", e);
                },
                keydown: (e) => {
                  this.$emit("keydown", e);
                },
                blur: (e) => {
                  if (this.hideIfFocusOutside) {
                    this.hideIfFocusOutside(e);
                  }
                  this.$emit("blur", e);
                },
                focus: (e) => {
                  if (this.show) {
                    this.show();
                  }
                  this.$emit("focus", e);
                }
              }
            })
          ];
          if (this.clearable && this.hasValue) {
            const clearButtonSlot = this.$scopedSlots.clearButton ? this.$scopedSlots.clearButton({
              className: this.getElementCssClass("clearButtonIcon"),
              formatedDate: this.formatedDate,
              userFormatedDate: this.userFormatedDate,
              value: this.value,
              activeDate: this.activeDate
            }) : [
              createElement("svg", {
                attrs: {
                  fill: "currentColor",
                  xmlns: "http://www.w3.org/2000/svg",
                  viewBox: "0 0 20 20"
                },
                class: this.getElementCssClass("clearButtonIcon")
              }, [
                createElement("polygon", {
                  attrs: {
                    points: "10 8.58578644 2.92893219 1.51471863 1.51471863 2.92893219 8.58578644 10 1.51471863 17.0710678 2.92893219 18.4852814 10 11.4142136 17.0710678 18.4852814 18.4852814 17.0710678 11.4142136 10 18.4852814 2.92893219 17.0710678 1.51471863 10 8.58578644"
                  }
                })
              ])
            ];
            subElements.push(createElement("button", {
              ref: "clearButton",
              class: this.getElementCssClass("clearButton"),
              attrs: {
                type: "button",
                tabindex: -1
              },
              on: {
                click: this.clearButtonClickHandler
              }
            }, clearButtonSlot));
          }
          if (this.multiple) {
            const dates = Array.isArray(formattedDate) ? formattedDate : [formattedDate];
            const hiddenInputs = dates.map((date) => createElement("input", {
              attrs: {
                type: "hidden",
                value: date,
                name: this.name,
                disabled: this.disabled,
                readonly: this.readonly,
                required: this.required
              }
            }));
            subElements.push(...hiddenInputs);
          } else {
            subElements.push(createElement("input", {
              attrs: {
                type: "hidden",
                value: Array.isArray(formattedDate) ? formattedDate.join(this.conjunction) : formattedDate,
                name: this.name,
                disabled: this.disabled,
                readonly: this.readonly,
                required: this.required
              }
            }));
          }
          return createElement("div", {
            class: this.getElementCssClass("inputWrapper")
          }, subElements);
        }
      });
      const TDatepickerViewsViewCalendarDaysDay = Vue__default["default"].extend({
        name: "TDatepickerViewsViewCalendarDaysDay",
        props: {
          day: {
            type: Date,
            required: true
          },
          value: {
            type: [Date, Array],
            default: null
          },
          activeDate: {
            type: Date,
            required: true
          },
          activeMonth: {
            type: Date,
            required: true
          },
          getElementCssClass: {
            type: Function,
            required: true
          },
          parse: {
            type: Function,
            required: true
          },
          format: {
            type: Function,
            required: true
          },
          formatNative: {
            type: Function,
            required: true
          },
          dateFormat: {
            type: String,
            required: true
          },
          userFormat: {
            type: String,
            required: true
          },
          showDaysForOtherMonth: {
            type: Boolean,
            required: true
          },
          showActiveDate: {
            type: Boolean,
            required: true
          },
          disabledDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          highlightDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          maxDate: {
            type: [Date, String],
            default: void 0
          },
          minDate: {
            type: [Date, String],
            default: void 0
          },
          range: {
            type: Boolean,
            required: true
          },
          dateWithoutTime: {
            type: Date,
            default: null
          }
        },
        data() {
          return {
            localActiveDate: new Date(this.activeDate.valueOf()),
            localActiveMonth: new Date(this.activeMonth.valueOf())
          };
        },
        computed: {
          isSelected() {
            const d1 = this.getDay();
            const d2 = this.getSelectedDay();
            if (d2 instanceof Date) {
              return isSameDay(d1, d2);
            }
            if (Array.isArray(d2)) {
              return d2.some((d) => isSameDay(d, d1));
            }
            return false;
          },
          isActive() {
            const d1 = this.getDay();
            const d2 = this.localActiveDate;
            return isSameDay(d1, d2);
          },
          isToday() {
            const d1 = this.getDay();
            const d2 = new Date();
            return isSameDay(d1, d2);
          },
          isDisabled() {
            const day = this.getDay();
            const disabledDates = this.disabledDates;
            const dateParser = this.parse;
            return dateIsOutOfRange(day, this.minDate, this.maxDate, dateParser, this.dateFormat) || dayIsPartOfTheConditions(day, disabledDates, dateParser, this.dateFormat);
          },
          isHighlighted() {
            const day = this.getDay();
            const highlightDates = this.highlightDates;
            const dateParser = this.parse;
            return dayIsPartOfTheConditions(day, highlightDates, dateParser, this.dateFormat);
          },
          isForAnotherMonth() {
            const d1 = this.localActiveMonth;
            const d2 = this.getDay();
            return d1.getFullYear() !== d2.getFullYear() || d1.getMonth() !== d2.getMonth();
          },
          isInRange() {
            if (!this.range || !Array.isArray(this.value)) {
              return false;
            }
            const [from, to] = this.value;
            if (from && to) {
              return !dateIsOutOfRange(this.getDay(), addDays(from, 1), addDays(to, -1));
            }
            return false;
          },
          isFirstDayOfRange() {
            if (!this.range || !Array.isArray(this.value)) {
              return false;
            }
            const [from] = this.value;
            return from && isSameDay(from, this.getDay());
          },
          isLastDayOfRange() {
            if (!this.range || !Array.isArray(this.value)) {
              return false;
            }
            const [, to] = this.value;
            return to && isSameDay(to, this.getDay());
          },
          dayFormatted() {
            return this.formatNative(this.getDay(), "j");
          },
          ariaLabel() {
            return this.format(this.getDay(), this.userFormat);
          },
          dateFormatted() {
            return this.format(this.getDay(), "Y-m-d");
          }
        },
        watch: {
          activeDate(activeDate) {
            this.localActiveDate = new Date(activeDate.valueOf());
          },
          activeMonth(activeMonth) {
            this.localActiveMonth = new Date(activeMonth.valueOf());
          }
        },
        methods: {
          getClass() {
            if (this.isForAnotherMonth) {
              return this.getElementCssClass("otherMonthDay");
            }
            if (this.isFirstDayOfRange) {
              return this.getElementCssClass("inRangeFirstDay");
            }
            if (this.isLastDayOfRange) {
              return this.getElementCssClass("inRangeLastDay");
            }
            if (this.isInRange) {
              return this.getElementCssClass("inRangeDay");
            }
            if (this.isSelected) {
              return this.getElementCssClass("selectedDay");
            }
            if (this.isActive && this.showActiveDate) {
              return this.getElementCssClass("activeDay");
            }
            if (this.isHighlighted) {
              return this.getElementCssClass("highlightedDay");
            }
            if (this.isToday) {
              return this.getElementCssClass("today");
            }
            return this.getElementCssClass("day");
          },
          getDay() {
            return this.day;
          },
          getSelectedDay() {
            if (this.dateWithoutTime !== null) {
              return this.dateWithoutTime;
            }
            return this.value;
          }
        },
        render(createElement) {
          if (this.isForAnotherMonth && !this.showDaysForOtherMonth) {
            return createElement("span", {
              class: this.getElementCssClass("emptyDay")
            }, "");
          }
          const daySlot = this.$scopedSlots.day ? this.$scopedSlots.day({
            dayFormatted: this.dayFormatted,
            isForAnotherMonth: this.isForAnotherMonth,
            isFirstDayOfRange: this.isFirstDayOfRange,
            isLastDayOfRange: this.isLastDayOfRange,
            isInRange: this.isInRange,
            isSelected: this.isSelected,
            isActive: this.isActive,
            isHighlighted: this.isHighlighted,
            isToday: this.isToday,
            day: this.getDay(),
            activeDate: this.activeDate,
            value: this.value
          }) : this.dayFormatted;
          return createElement("button", {
            class: this.getClass(),
            attrs: {
              "aria-label": this.ariaLabel,
              "aria-current": this.isToday ? "date" : void 0,
              "data-date": this.dateFormatted,
              type: "button",
              tabindex: -1,
              disabled: this.isDisabled ? true : void 0
            },
            on: {
              click: (e) => this.$emit("click", e)
            }
          }, daySlot);
        }
      });
      const TDatepickerViewsViewCalendarDays = Vue__default["default"].extend({
        name: "TDatepickerViewsViewCalendarDays",
        props: {
          value: {
            type: [Date, Array],
            default: null
          },
          activeDate: {
            type: Date,
            required: true
          },
          activeMonth: {
            type: Date,
            required: true
          },
          weekStart: {
            type: Number,
            required: true
          },
          getElementCssClass: {
            type: Function,
            required: true
          },
          parse: {
            type: Function,
            required: true
          },
          format: {
            type: Function,
            required: true
          },
          formatNative: {
            type: Function,
            required: true
          },
          userFormat: {
            type: String,
            required: true
          },
          dateFormat: {
            type: String,
            required: true
          },
          showDaysForOtherMonth: {
            type: Boolean,
            required: true
          },
          showActiveDate: {
            type: Boolean,
            required: true
          },
          disabledDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          highlightDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          maxDate: {
            type: [Date, String],
            default: void 0
          },
          minDate: {
            type: [Date, String],
            default: void 0
          },
          range: {
            type: Boolean,
            required: true
          },
          timepicker: {
            type: Boolean,
            required: true
          },
          dateWithoutTime: {
            type: Date,
            default: null
          }
        },
        data() {
          return {
            localActiveDate: new Date(this.activeDate.valueOf()),
            localActiveMonth: new Date(this.activeMonth.valueOf())
          };
        },
        computed: {
          firstDayOfMonth() {
            const localActiveDate = new Date(this.localActiveMonth.valueOf());
            localActiveDate.setDate(1);
            return localActiveDate;
          },
          lastDayOfMonth() {
            return lastDayOfMonth(this.localActiveMonth);
          },
          firstDayOfPrevMonth() {
            return new Date(this.localActiveMonth.getFullYear(), this.localActiveMonth.getMonth() - 1, 1);
          },
          lastDayOfPrevMonth() {
            const localActiveDate = new Date(this.localActiveMonth.valueOf());
            localActiveDate.setDate(0);
            return localActiveDate;
          },
          firstDayOfNextMonth() {
            const localActiveDate = new Date(this.localActiveMonth.valueOf());
            localActiveDate.setDate(1);
            localActiveDate.setMonth(this.localActiveMonth.getMonth() + 1);
            return localActiveDate;
          },
          monthDays() {
            return Array.from({ length: this.lastDayOfMonth.getDate() }, (_x, i) => i + 1).map((day) => this.getDay(this.localActiveMonth, day));
          },
          prevMonthDays() {
            let prevMonthTotalDays = this.firstDayOfMonth.getDay() - this.weekStart;
            if (prevMonthTotalDays < 0) {
              prevMonthTotalDays = 7 + prevMonthTotalDays;
            }
            return Array.from({ length: prevMonthTotalDays }, (_x, i) => this.lastDayOfPrevMonth.getDate() - i).reverse().map((day) => this.getDay(this.firstDayOfPrevMonth, day));
          },
          nextMonthDays() {
            const nextMonthTotalDays = 7 - this.monthDays.concat(this.prevMonthDays).length % 7;
            if (nextMonthTotalDays === 7) {
              return [];
            }
            return Array.from({ length: nextMonthTotalDays }, (_x, i) => i + 1).map((day) => this.getDay(this.firstDayOfNextMonth, day));
          },
          days() {
            const { prevMonthDays } = this;
            const { monthDays } = this;
            const { nextMonthDays } = this;
            return prevMonthDays.concat(monthDays, nextMonthDays);
          }
        },
        watch: {
          activeDate(activeDate) {
            this.localActiveDate = new Date(activeDate.valueOf());
          },
          activeMonth(activeMonth) {
            this.localActiveMonth = new Date(activeMonth.valueOf());
          }
        },
        methods: {
          getDay(date, dayNumber) {
            const day = new Date(date.valueOf());
            day.setDate(dayNumber);
            return day;
          }
        },
        render(createElement) {
          return createElement("div", {
            class: this.getElementCssClass("calendarDaysWrapper")
          }, this.days.map((day) => createElement("span", {
            class: this.getElementCssClass("calendarDaysDayWrapper")
          }, [
            createElement(TDatepickerViewsViewCalendarDaysDay, {
              props: {
                day,
                value: this.value,
                activeDate: this.localActiveDate,
                activeMonth: this.localActiveMonth,
                getElementCssClass: this.getElementCssClass,
                parse: this.parse,
                format: this.format,
                formatNative: this.formatNative,
                dateFormat: this.dateFormat,
                userFormat: this.userFormat,
                showDaysForOtherMonth: this.showDaysForOtherMonth,
                showActiveDate: this.showActiveDate,
                disabledDates: this.disabledDates,
                highlightDates: this.highlightDates,
                minDate: this.minDate,
                maxDate: this.maxDate,
                range: this.range,
                dateWithoutTime: this.dateWithoutTime
              },
              scopedSlots: this.$scopedSlots,
              on: {
                click: () => {
                  if (this.timepicker) {
                    this.$emit("input-date", day);
                  } else {
                    this.$emit("input", day);
                  }
                }
              }
            })
          ])));
        }
      });
      const TDatepickerViewsViewCalendarHeaders = Vue__default["default"].extend({
        name: "TDatepickerViewsViewCalendarHeaders",
        props: {
          weekStart: {
            type: Number,
            required: true
          },
          getElementCssClass: {
            type: Function,
            required: true
          },
          formatNative: {
            type: Function,
            required: true
          }
        },
        computed: {
          weekDays() {
            return Array.from({ length: 7 }, (_x, i) => {
              const weekDay = this.weekStart + i;
              if (weekDay >= 7) {
                return weekDay - 7;
              }
              return weekDay;
            }).map(this.getWeekDayName);
          }
        },
        methods: {
          getWeekDayName(weekDay) {
            const date = new Date();
            date.setDate((date.getDate() + (7 + weekDay - date.getDay())) % 7);
            return this.formatNative(date, "D");
          }
        },
        render(createElement) {
          return createElement("div", {
            class: this.getElementCssClass("calendarHeaderWrapper")
          }, this.weekDays.map((weekDayName) => createElement("span", {
            class: this.getElementCssClass("calendarHeaderWeekDay")
          }, weekDayName)));
        }
      });
      const TDatepickerViewsViewCalendar = Vue__default["default"].extend({
        name: "TDatepickerViewsViewCalendar",
        props: {
          value: {
            type: [Date, Array],
            default: null
          },
          activeDate: {
            type: Date,
            required: true
          },
          activeMonth: {
            type: Date,
            required: true
          },
          weekStart: {
            type: Number,
            required: true
          },
          getElementCssClass: {
            type: Function,
            required: true
          },
          parse: {
            type: Function,
            required: true
          },
          format: {
            type: Function,
            required: true
          },
          formatNative: {
            type: Function,
            required: true
          },
          dateFormat: {
            type: String,
            required: true
          },
          userFormat: {
            type: String,
            required: true
          },
          monthsPerView: {
            type: Number,
            required: true
          },
          showActiveDate: {
            type: Boolean,
            required: true
          },
          disabledDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          highlightDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          maxDate: {
            type: [Date, String],
            default: void 0
          },
          minDate: {
            type: [Date, String],
            default: void 0
          },
          range: {
            type: Boolean,
            required: true
          },
          showDaysForOtherMonth: {
            type: Boolean,
            required: true
          },
          timepicker: {
            type: Boolean,
            required: true
          },
          dateWithoutTime: {
            type: Date,
            default: null
          }
        },
        data() {
          return {
            localActiveDate: new Date(this.activeDate.valueOf()),
            localActiveMonth: new Date(this.activeMonth.valueOf())
          };
        },
        watch: {
          activeDate(activeDate) {
            this.localActiveDate = new Date(activeDate.valueOf());
          },
          activeMonth(activeMonth) {
            this.localActiveMonth = new Date(activeMonth.valueOf());
          }
        },
        render(createElement) {
          return createElement("div", {
            class: this.getElementCssClass("calendarWrapper")
          }, [
            createElement(TDatepickerViewsViewCalendarHeaders, {
              props: {
                weekStart: this.weekStart,
                getElementCssClass: this.getElementCssClass,
                formatNative: this.formatNative
              }
            }),
            createElement(TDatepickerViewsViewCalendarDays, {
              ref: "days",
              props: {
                value: this.value,
                activeDate: this.localActiveDate,
                activeMonth: this.localActiveMonth,
                weekStart: this.weekStart,
                getElementCssClass: this.getElementCssClass,
                parse: this.parse,
                format: this.format,
                formatNative: this.formatNative,
                userFormat: this.userFormat,
                dateFormat: this.dateFormat,
                showDaysForOtherMonth: this.monthsPerView > 1 ? false : this.showDaysForOtherMonth,
                showActiveDate: this.showActiveDate,
                disabledDates: this.disabledDates,
                highlightDates: this.highlightDates,
                minDate: this.minDate,
                maxDate: this.maxDate,
                range: this.range,
                timepicker: this.timepicker,
                dateWithoutTime: this.dateWithoutTime
              },
              scopedSlots: this.$scopedSlots,
              on: {
                input: (date) => this.$emit("input", date),
                "input-date": (date) => this.$emit("input-date", date)
              }
            })
          ]);
        }
      });
      const TDatepickerViewsViewMonthsMonth = Vue__default["default"].extend({
        name: "TDatepickerViewsViewMonthsMonth",
        props: {
          month: {
            type: Date,
            required: true
          },
          value: {
            type: [Date, Array],
            default: null
          },
          activeDate: {
            type: Date,
            required: true
          },
          getElementCssClass: {
            type: Function,
            required: true
          },
          formatNative: {
            type: Function,
            required: true
          },
          showActiveDate: {
            type: Boolean,
            required: true
          }
        },
        computed: {
          isSelected() {
            const d1 = this.getMonth();
            const d2 = this.value;
            if (d2 instanceof Date) {
              return isSameMonth(d1, d2);
            }
            if (Array.isArray(d2)) {
              return d2.some((d) => isSameMonth(d, d1));
            }
            return false;
          },
          isActive() {
            const d1 = this.getMonth();
            const d2 = this.activeDate;
            return isSameMonth(d1, d2);
          },
          monthFormatted() {
            return this.formatNative(this.getMonth(), "M");
          }
        },
        methods: {
          getClass() {
            if (this.isSelected) {
              return this.getElementCssClass("selectedMonth");
            }
            if (this.isActive && this.showActiveDate) {
              return this.getElementCssClass("activeMonth");
            }
            return this.getElementCssClass("month");
          },
          getMonth() {
            return this.month;
          }
        },
        render(createElement) {
          const monthSlot = this.$scopedSlots.month ? this.$scopedSlots.month({
            monthFormatted: this.monthFormatted,
            isSelected: this.isSelected,
            isActive: this.isActive,
            month: this.getMonth(),
            activeDate: this.activeDate,
            value: this.value
          }) : this.monthFormatted;
          return createElement("button", {
            class: this.getClass(),
            attrs: {
              "aria-label": this.formatNative(this.getMonth(), "F, Y"),
              "data-date": this.formatNative(this.getMonth(), "Y-m"),
              type: "button",
              tabindex: -1
            },
            on: {
              click: (e) => this.$emit("click", e)
            }
          }, monthSlot);
        }
      });
      const TDatepickerViewsViewMonths = Vue__default["default"].extend({
        name: "TDatepickerViewsViewMonths",
        props: {
          value: {
            type: [Date, Array],
            default: null
          },
          activeDate: {
            type: Date,
            required: true
          },
          getElementCssClass: {
            type: Function,
            required: true
          },
          showActiveDate: {
            type: Boolean,
            required: true
          },
          formatNative: {
            type: Function,
            required: true
          }
        },
        data() {
          return {
            localActiveDate: new Date(this.activeDate.valueOf())
          };
        },
        computed: {
          months() {
            return Array.from({ length: 12 }, (_x, i) => i).map((monthNumber) => this.getMonth(monthNumber));
          }
        },
        watch: {
          activeDate(activeDate) {
            this.localActiveDate = new Date(activeDate.valueOf());
          }
        },
        methods: {
          getMonth(monthNumber) {
            let newDate = new Date(this.localActiveDate.valueOf());
            newDate.setMonth(monthNumber);
            if (newDate.getDate() !== this.localActiveDate.getDate()) {
              newDate = new Date(newDate.getFullYear(), newDate.getMonth(), 0);
            }
            return newDate;
          }
        },
        render(createElement) {
          return createElement("div", {
            class: this.getElementCssClass("monthWrapper")
          }, this.months.map((month) => createElement(TDatepickerViewsViewMonthsMonth, {
            props: {
              month,
              value: this.value,
              activeDate: this.localActiveDate,
              getElementCssClass: this.getElementCssClass,
              showActiveDate: this.showActiveDate,
              formatNative: this.formatNative
            },
            scopedSlots: this.$scopedSlots,
            on: {
              click: () => this.$emit("input", month)
            }
          })));
        }
      });
      const TDatepickerViewsViewYearsYear = Vue__default["default"].extend({
        name: "TDatepickerViewsViewYearsYear",
        props: {
          year: {
            type: Date,
            required: true
          },
          activeDate: {
            type: Date,
            required: true
          },
          value: {
            type: [Date, Array],
            default: null
          },
          getElementCssClass: {
            type: Function,
            required: true
          },
          showActiveDate: {
            type: Boolean,
            required: true
          },
          formatNative: {
            type: Function,
            required: true
          }
        },
        data() {
          return {
            localActiveDate: new Date(this.activeDate.valueOf())
          };
        },
        computed: {
          isSelected() {
            const d1 = this.getYear();
            const d2 = this.value;
            if (d2 instanceof Date) {
              return d1.getFullYear() === d2.getFullYear();
            }
            if (Array.isArray(d2)) {
              return d2.some((d) => d.getFullYear() === d1.getFullYear());
            }
            return false;
          },
          isActive() {
            const d1 = this.getYear();
            const d2 = this.activeDate;
            return d2 && d1.getFullYear() === d2.getFullYear();
          },
          yearFormatted() {
            return this.formatNative(this.getYear(), "Y");
          }
        },
        watch: {
          activeDate(activeDate) {
            this.localActiveDate = new Date(activeDate.valueOf());
          }
        },
        methods: {
          getClass() {
            if (this.isSelected) {
              return this.getElementCssClass("selectedYear");
            }
            if (this.isActive && this.showActiveDate) {
              return this.getElementCssClass("activeYear");
            }
            return this.getElementCssClass("year");
          },
          getYear() {
            return this.year;
          }
        },
        render(createElement) {
          const yearSlot = this.$scopedSlots.year ? this.$scopedSlots.year({
            yearFormatted: this.yearFormatted,
            isSelected: this.isSelected,
            isActive: this.isActive,
            year: this.getYear(),
            activeDate: this.activeDate,
            value: this.value
          }) : this.yearFormatted;
          return createElement("button", {
            class: this.getClass(),
            attrs: {
              "aria-label": this.yearFormatted,
              "data-date": this.yearFormatted,
              type: "button",
              tabindex: -1
            },
            on: {
              click: (e) => this.$emit("click", e)
            }
          }, yearSlot);
        }
      });
      const TDatepickerViewsViewYears = Vue__default["default"].extend({
        name: "TDatepickerViewsViewYears",
        props: {
          value: {
            type: [Date, Array],
            default: null
          },
          activeDate: {
            type: Date,
            required: true
          },
          getElementCssClass: {
            type: Function,
            required: true
          },
          yearsPerView: {
            type: Number,
            required: true
          },
          showActiveDate: {
            type: Boolean,
            required: true
          },
          formatNative: {
            type: Function,
            required: true
          }
        },
        data() {
          return {
            localActiveDate: new Date(this.activeDate.valueOf())
          };
        },
        computed: {
          years() {
            const [initialYear] = getYearsRange(this.localActiveDate, this.yearsPerView);
            return Array.from({ length: this.yearsPerView }, (_x, i) => i).map((year) => this.getYear(initialYear + year));
          }
        },
        watch: {
          activeDate(activeDate) {
            this.localActiveDate = new Date(activeDate.valueOf());
          }
        },
        methods: {
          getYear(year) {
            let newDate = new Date(this.localActiveDate.valueOf());
            newDate.setFullYear(year);
            if (newDate.getDate() !== this.localActiveDate.getDate()) {
              newDate = new Date(newDate.getFullYear(), newDate.getMonth(), 0);
            }
            return newDate;
          }
        },
        render(createElement) {
          return createElement("div", {
            class: this.getElementCssClass("yearWrapper")
          }, this.years.map((year) => createElement(TDatepickerViewsViewYearsYear, {
            props: {
              year,
              activeDate: this.localActiveDate,
              value: this.value,
              getElementCssClass: this.getElementCssClass,
              showActiveDate: this.showActiveDate,
              formatNative: this.formatNative
            },
            scopedSlots: this.$scopedSlots,
            on: {
              click: () => this.$emit("input", year)
            }
          })));
        }
      });
      const TDatepickerViewsView = Vue__default["default"].extend({
        name: "TDatepickerViewsView",
        props: {
          value: {
            type: [Date, Array],
            default: null
          },
          activeMonth: {
            type: Date,
            required: true
          },
          activeDate: {
            type: Date,
            required: true
          },
          weekStart: {
            type: Number,
            required: true
          },
          lang: {
            type: String,
            required: true
          },
          getElementCssClass: {
            type: Function,
            required: true
          },
          formatNative: {
            type: Function,
            required: true
          },
          parse: {
            type: Function,
            required: true
          },
          format: {
            type: Function,
            required: true
          },
          userFormat: {
            type: String,
            required: true
          },
          dateFormat: {
            type: String,
            required: true
          },
          monthsPerView: {
            type: Number,
            required: true
          },
          monthIndex: {
            type: Number,
            required: true
          },
          currentView: {
            type: String,
            required: true
          },
          yearsPerView: {
            type: Number,
            required: true
          },
          showActiveDate: {
            type: Boolean,
            required: true
          },
          showDaysForOtherMonth: {
            type: Boolean,
            required: true
          },
          disabledDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          highlightDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          maxDate: {
            type: [Date, String],
            default: void 0
          },
          minDate: {
            type: [Date, String],
            default: void 0
          },
          range: {
            type: Boolean,
            required: true
          },
          locale: {
            type: Object,
            required: true
          },
          timepicker: {
            type: Boolean,
            required: true
          },
          dateWithoutTime: {
            type: Date,
            default: null
          }
        },
        data() {
          return {
            localActiveDate: new Date(this.activeDate.valueOf()),
            localActiveMonth: new Date(this.activeMonth.valueOf())
          };
        },
        computed: {
          isFirstMonth() {
            return this.monthIndex === 0;
          },
          isLastMonth() {
            return this.monthIndex === this.monthsPerView - 1;
          },
          showMonthName() {
            return this.monthsPerView > 1;
          }
        },
        watch: {
          activeDate(activeDate) {
            this.localActiveDate = new Date(activeDate.valueOf());
          },
          activeMonth(activeMonth) {
            this.localActiveMonth = new Date(activeMonth.valueOf());
          }
        },
        methods: {
          inputHandler(date) {
            this.resetView();
            this.$emit("input", date);
          },
          inputDateHandler(date) {
            this.$emit("input-date", date);
          },
          viewInputActiveDateHandler(date) {
            this.resetView();
            this.inputActiveDateHandler(date);
          },
          inputActiveDateHandler(date) {
            this.$emit("input-active-date", date);
            this.resetFocus();
          },
          resetFocus() {
            this.$emit("reset-focus");
          },
          resetView() {
            this.$emit("reset-view");
          }
        },
        render(createElement) {
          const subElements = [];
          subElements.push(createElement(TDatepickerNavigator, {
            ref: "navigator",
            props: {
              value: this.localActiveMonth,
              getElementCssClass: this.getElementCssClass,
              showSelector: this.isFirstMonth,
              currentView: this.currentView,
              parse: this.parse,
              formatNative: this.formatNative,
              dateFormat: this.dateFormat,
              yearsPerView: this.yearsPerView,
              minDate: this.minDate,
              maxDate: this.maxDate,
              locale: this.locale
            },
            on: {
              input: this.inputActiveDateHandler,
              "update-view": (newView) => {
                this.$emit("update-view", newView);
              }
            }
          }));
          if (this.currentView === CalendarView.Day) {
            subElements.push(createElement(TDatepickerViewsViewCalendar, {
              ref: "calendar",
              props: {
                value: this.value,
                activeMonth: this.localActiveMonth,
                activeDate: this.localActiveDate,
                weekStart: this.weekStart,
                getElementCssClass: this.getElementCssClass,
                showDaysForOtherMonth: this.showDaysForOtherMonth,
                parse: this.parse,
                format: this.format,
                formatNative: this.formatNative,
                dateFormat: this.dateFormat,
                userFormat: this.userFormat,
                monthsPerView: this.monthsPerView,
                showActiveDate: this.showActiveDate,
                disabledDates: this.disabledDates,
                highlightDates: this.highlightDates,
                minDate: this.minDate,
                maxDate: this.maxDate,
                range: this.range,
                timepicker: this.timepicker,
                dateWithoutTime: this.dateWithoutTime
              },
              scopedSlots: this.$scopedSlots,
              on: {
                input: this.inputHandler,
                "input-date": this.inputDateHandler
              }
            }));
          } else if (this.currentView === CalendarView.Month) {
            subElements.push(createElement(TDatepickerViewsViewMonths, {
              ref: "months",
              props: {
                value: this.value,
                activeDate: this.localActiveDate,
                getElementCssClass: this.getElementCssClass,
                showActiveDate: this.showActiveDate,
                formatNative: this.formatNative
              },
              scopedSlots: this.$scopedSlots,
              on: {
                input: this.viewInputActiveDateHandler
              }
            }));
          } else if (this.currentView === CalendarView.Year) {
            subElements.push(createElement(TDatepickerViewsViewYears, {
              ref: "years",
              props: {
                value: this.value,
                activeDate: this.localActiveDate,
                getElementCssClass: this.getElementCssClass,
                yearsPerView: this.yearsPerView,
                showActiveDate: this.showActiveDate,
                formatNative: this.formatNative
              },
              scopedSlots: this.$scopedSlots,
              on: {
                input: this.viewInputActiveDateHandler
              }
            }));
          }
          return createElement("div", {
            class: this.getElementCssClass("view")
          }, subElements);
        }
      });
      const TDatepickerViews = Vue__default["default"].extend({
        name: "TDatepickerViews",
        props: {
          value: {
            type: [Date, Array],
            default: null
          },
          activeDate: {
            type: Date,
            required: true
          },
          weekStart: {
            type: Number,
            required: true
          },
          monthsPerView: {
            type: Number,
            required: true
          },
          lang: {
            type: String,
            required: true
          },
          getElementCssClass: {
            type: Function,
            required: true
          },
          parse: {
            type: Function,
            required: true
          },
          format: {
            type: Function,
            required: true
          },
          formatNative: {
            type: Function,
            required: true
          },
          dateFormat: {
            type: String,
            required: true
          },
          userFormat: {
            type: String,
            required: true
          },
          initialView: {
            type: String,
            required: true
          },
          currentView: {
            type: String,
            required: true
          },
          yearsPerView: {
            type: Number,
            required: true
          },
          showActiveDate: {
            type: Boolean,
            required: true
          },
          showDaysForOtherMonth: {
            type: Boolean,
            required: true
          },
          disabledDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          highlightDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          maxDate: {
            type: [Date, String],
            default: void 0
          },
          minDate: {
            type: [Date, String],
            default: void 0
          },
          range: {
            type: Boolean,
            required: true
          },
          locale: {
            type: Object,
            required: true
          },
          timepicker: {
            type: Boolean,
            required: true
          },
          dateWithoutTime: {
            type: Date,
            default: null
          }
        },
        data() {
          return {
            localActiveDate: new Date(this.activeDate.valueOf())
          };
        },
        computed: {
          activeMonths() {
            return Array.from({ length: this.monthsPerView }, (_x, i) => i).map((i) => addMonths(this.localActiveDate, i));
          }
        },
        watch: {
          activeDate(activeDate) {
            this.localActiveDate = new Date(activeDate.valueOf());
          }
        },
        render(createElement) {
          const subElements = this.activeMonths.map((activeMonth, index) => createElement(TDatepickerViewsView, {
            ref: "view",
            props: {
              value: this.value,
              activeMonth,
              activeDate: this.localActiveDate,
              weekStart: this.weekStart,
              lang: this.lang,
              getElementCssClass: this.getElementCssClass,
              parse: this.parse,
              format: this.format,
              dateFormat: this.dateFormat,
              userFormat: this.userFormat,
              formatNative: this.formatNative,
              monthsPerView: this.monthsPerView,
              monthIndex: index,
              currentView: index === 0 ? this.currentView : this.initialView,
              yearsPerView: this.yearsPerView,
              showActiveDate: this.showActiveDate,
              disabledDates: this.disabledDates,
              highlightDates: this.highlightDates,
              minDate: this.minDate,
              maxDate: this.maxDate,
              range: this.range,
              showDaysForOtherMonth: this.showDaysForOtherMonth,
              locale: this.locale,
              timepicker: this.timepicker,
              dateWithoutTime: this.dateWithoutTime
            },
            scopedSlots: this.$scopedSlots,
            on: {
              input: (date) => {
                this.$emit("input", date);
              },
              "input-date": (date) => {
                this.$emit("input-date", date);
              },
              "input-time": (date) => {
                this.$emit("input-time", date);
              },
              "input-active-date": (date) => {
                this.$emit("input-active-date", date);
              },
              "update-view": (newView) => {
                this.$emit("update-view", newView);
              },
              "reset-view": () => {
                this.$emit("reset-view");
              },
              "reset-focus": () => {
                this.$emit("reset-focus");
              }
            }
          }));
          return createElement("div", {
            class: this.getElementCssClass("viewGroup")
          }, subElements);
        }
      });
      const isChecked = (model, value) => {
        if (Array.isArray(model)) {
          return model.indexOf(value) >= 0;
        }
        return model === value;
      };
      const TToggle = HtmlInput.extend({
        name: "TToggle",
        props: {
          value: {
            type: [String, Object, Number, Boolean, Array],
            default: true
          },
          uncheckedValue: {
            type: [String, Object, Number, Boolean, Array],
            default: false
          },
          model: {
            type: [String, Object, Number, Boolean, Array],
            default: void 0
          },
          checked: {
            type: Boolean,
            default: void 0
          },
          tabindex: {
            type: [String, Number],
            default: 0
          },
          uncheckedPlaceholder: {
            type: String,
            default: void 0
          },
          checkedPlaceholder: {
            type: String,
            default: void 0
          },
          uncheckedLabel: {
            type: String,
            default: void 0
          },
          checkedLabel: {
            type: String,
            default: void 0
          },
          classes: {
            type: Object,
            default() {
              return {
                wrapper: "bg-gray-100 rounded-full border-2 border-transparent focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
                wrapperChecked: "bg-blue-500 rounded-full border-2 border-transparent focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
                wrapperDisabled: "bg-gray-100 rounded-full border-2 border-transparent focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
                wrapperCheckedDisabled: "bg-blue-500 rounded-full border-2 border-transparent focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
                button: "h-5 w-5 rounded-full bg-white shadow flex items-center justify-center text-gray-400 text-xs",
                buttonChecked: "h-5 w-5 rounded-full bg-white shadow flex items-center justify-center text-blue-500 text-xs",
                checkedPlaceholder: "rounded-full w-5 h-5 flex items-center justify-center text-gray-400 text-xs",
                uncheckedPlaceholder: "rounded-full w-5 h-5 flex items-center justify-center text-gray-400 text-xs"
              };
            }
          },
          fixedClasses: {
            type: [String, Array, Object],
            default() {
              return {
                wrapper: "relative inline-flex flex-shrink-0 cursor-pointer transition-colors ease-in-out duration-200",
                wrapperChecked: "relative inline-flex flex-shrink-0 cursor-pointer transition-colors ease-in-out duration-200",
                wrapperDisabled: "relative inline-flex flex-shrink-0 cursor-pointer transition-colors ease-in-out duration-200 opacity-50 cursor-not-allowed",
                wrapperCheckedDisabled: "relative inline-flex flex-shrink-0 cursor-pointer transition-colors ease-in-out duration-200 opacity-50 cursor-not-allowed",
                button: "inline-block absolute transform translate-x-0 transition ease-in-out duration-200",
                buttonChecked: "inline-block absolute transform translate-x-full transition ease-in-out duration-200",
                checkedPlaceholder: "inline-block",
                uncheckedPlaceholder: "inline-block"
              };
            }
          }
        },
        model: {
          prop: "model",
          event: "input"
        },
        data() {
          const checked = typeof this.checked === "boolean" && typeof this.model === "undefined" ? this.checked : isChecked(this.model, this.value);
          return {
            isChecked: checked
          };
        },
        computed: {
          isDisabled() {
            return this.disabled || this.readonly;
          },
          currentValue() {
            return this.isChecked ? this.value : this.uncheckedValue;
          }
        },
        watch: {
          model(model) {
            this.isChecked = isChecked(model, this.value);
          },
          isChecked(checked) {
            let localValue;
            if (Array.isArray(this.model)) {
              localValue = [...this.model];
              const index = localValue.indexOf(this.value);
              if (checked && index < 0) {
                localValue.push(this.value);
              } else if (!checked && index >= 0) {
                localValue.splice(index, 1);
              }
            } else {
              localValue = this.currentValue;
            }
            this.$emit("input", localValue);
            this.$emit("change", localValue);
            this.$emit("update:checked", checked);
          }
        },
        methods: {
          blurHandler(e) {
            this.$emit("blur", e);
          },
          focusHandler(e) {
            this.$emit("focus", e);
          },
          getElement() {
            return this.$el;
          },
          blur() {
            this.getElement().blur();
          },
          click() {
            this.getElement().click();
          },
          spaceHandler(e) {
            e.preventDefault();
            this.toggleValue();
          },
          clickHandler() {
            this.toggleValue();
          },
          toggleValue() {
            if (this.isDisabled) {
              return;
            }
            this.isChecked = !this.isChecked;
          },
          setChecked(checked) {
            this.isChecked = checked;
          },
          focus(options) {
            this.getElement().focus(options);
          }
        },
        render(createElement) {
          let wrapperClass;
          if (this.isDisabled) {
            if (this.isChecked) {
              wrapperClass = this.getElementCssClass("wrapperCheckedDisabled");
            } else {
              wrapperClass = this.getElementCssClass("wrapperDisabled");
            }
          } else if (this.isChecked) {
            wrapperClass = this.getElementCssClass("wrapperChecked");
          } else {
            wrapperClass = this.getElementCssClass("wrapper");
          }
          let defaultSlot = this.$scopedSlots.default ? this.$scopedSlots.default({
            value: this.currentValue,
            uncheckedValue: this.uncheckedValue,
            isChecked: this.isChecked
          }) : null;
          if (!defaultSlot) {
            defaultSlot = this.isChecked ? this.checkedLabel : this.uncheckedLabel;
          }
          let checkedslot = this.$scopedSlots.checked ? this.$scopedSlots.checked({
            value: this.currentValue,
            uncheckedValue: this.uncheckedValue,
            isChecked: this.isChecked
          }) : null;
          if (this.checkedPlaceholder && !checkedslot) {
            checkedslot = this.checkedPlaceholder;
          }
          let uncheckedSlot = this.$scopedSlots.unchecked ? this.$scopedSlots.unchecked({
            value: this.currentValue,
            uncheckedValue: this.uncheckedValue,
            isChecked: this.isChecked
          }) : null;
          if (this.uncheckedPlaceholder && !uncheckedSlot) {
            uncheckedSlot = this.uncheckedPlaceholder;
          }
          return createElement("span", {
            class: wrapperClass,
            attrs: {
              role: "checkbox",
              id: this.id,
              tabindex: this.tabindex,
              autofocus: this.autofocus,
              "aria-checked": this.isChecked ? "true" : "false"
            },
            on: {
              blur: this.blurHandler,
              focus: this.focusHandler,
              click: (e) => {
                this.clickHandler();
                this.$emit("click", e);
              },
              keydown: (e) => {
                if (e.keyCode === Key$1.SPACE) {
                  this.spaceHandler(e);
                }
                this.$emit("keydown", e);
              }
            }
          }, [
            createElement("input", {
              ref: "input",
              attrs: {
                value: this.currentValue,
                type: "hidden",
                name: this.name,
                disabled: this.disabled,
                readonly: this.readonly,
                required: this.required
              }
            }),
            createElement("span", {
              class: this.getElementCssClass("checkedPlaceholder"),
              attrs: {
                "aria-hidden": "true"
              }
            }, checkedslot),
            createElement("span", {
              class: this.getElementCssClass("uncheckedPlaceholder"),
              attrs: {
                "aria-hidden": "true"
              }
            }, uncheckedSlot),
            createElement("span", {
              ref: "button",
              class: this.isChecked ? this.getElementCssClass("buttonChecked") : this.getElementCssClass("button"),
              attrs: {
                "aria-hidden": "true"
              }
            }, defaultSlot)
          ]);
        }
      });
      const isNumeric = (char) => /^\d+$/.test(String(char));
      const TDatepickerTimeSelector = Vue__default["default"].extend({
        name: "TDatepickerTimeSelector",
        props: {
          parse: {
            type: Function,
            required: true
          },
          format: {
            type: Function,
            required: true
          },
          amPm: {
            type: Boolean,
            required: true
          },
          showSeconds: {
            type: Boolean,
            required: true
          },
          activeDate: {
            type: Date,
            required: true
          },
          locale: {
            type: Object,
            required: true
          },
          getElementCssClass: {
            type: Function,
            required: true
          }
        },
        data() {
          return {
            localActiveDate: new Date(this.activeDate.valueOf()),
            alreadyTriedAnInvalidValue: false,
            lastValidValue: "",
            timeInputKeys: []
          };
        },
        computed: {
          amPmFormatted() {
            if (!this.amPm) {
              return null;
            }
            return this.format(this.localActiveDate, "K");
          },
          minutesFormatted() {
            return this.format(this.localActiveDate, "i");
          },
          hoursFormatted() {
            if (this.amPm) {
              return this.format(this.localActiveDate, "G");
            }
            return this.format(this.localActiveDate, "H");
          },
          secondsFormatted() {
            return this.format(this.localActiveDate, "S");
          }
        },
        watch: {
          timeInputKeys(timeInputKeys) {
            const numbers = timeInputKeys.join("").substr(this.showSeconds ? -6 : -4);
            const minutesInput = this.$refs.minutes;
            const hoursInput = this.$refs.hours;
            const fullTime = numbers.padStart(this.showSeconds ? 6 : 4, " ").substr(this.showSeconds ? -6 : -4);
            if (this.showSeconds) {
              const secondsInput = this.$refs.seconds;
              secondsInput.value = fullTime.substr(4, 2).trim();
              minutesInput.value = fullTime.substr(2, 2).trim();
              hoursInput.value = fullTime.substr(0, 2).trim();
            } else {
              minutesInput.value = fullTime.substr(2, 2).trim();
              hoursInput.value = fullTime.substr(0, 2).trim();
            }
          },
          activeDate(activeDate) {
            this.localActiveDate = new Date(activeDate.valueOf());
            this.lastValidValue = "";
            this.alreadyTriedAnInvalidValue = false;
            this.timeInputKeys = [];
          }
        },
        methods: {
          handleFullTimeBlur(e) {
            this.$emit("blur", e);
            if (!this.timeInputKeys.length) {
              return;
            }
            const numbers = this.timeInputKeys.filter((key) => isNumeric(key)).join("").substr(this.showSeconds ? -6 : -4);
            const fullTime = numbers.padStart(this.showSeconds ? 6 : 4, "0").substr(this.showSeconds ? -6 : -4);
            let time;
            if (this.showSeconds) {
              if (this.amPm && Number(fullTime.substr(0, 2)) <= 12) {
                const formattedIntendedTime = `${fullTime.substr(0, 2)}:${fullTime.substr(2, 2)}:${fullTime.substr(4, 2)} ${this.amPmFormatted}`;
                time = this.parse(formattedIntendedTime, "H:i:S K");
              } else {
                const formattedIntendedTime = `${fullTime.substr(0, 2)}:${fullTime.substr(2, 2)}:${fullTime.substr(4, 2)}`;
                time = this.parse(formattedIntendedTime, "G:i:S");
              }
            } else if (this.amPm && Number(fullTime.substr(0, 2)) <= 12) {
              const formattedIntendedTime = `${fullTime.substr(0, 2)}:${fullTime.substr(2, 2)} ${this.amPmFormatted}`;
              time = this.parse(formattedIntendedTime, "H:i K");
            } else {
              const formattedIntendedTime = `${fullTime.substr(0, 2)}:${fullTime.substr(2, 2)}`;
              time = this.parse(formattedIntendedTime, "G:i");
            }
            if (time instanceof Date && !Number.isNaN(time)) {
              this.setHours(time.getHours());
              this.setMinutes(time.getMinutes());
              this.setSeconds(time.getSeconds());
              this.$emit("input", this.localActiveDate);
              this.$nextTick(() => {
                this.updateSecondsInput();
                this.updateMinutesInput();
                this.updateHoursInput();
              });
            }
            this.focusNextElementFullTimeSelector();
          },
          focusNextElementFullTimeSelector() {
            if (this.amPm) {
              this.$refs.amPm.focus();
            } else {
              this.focusOkButton();
            }
          },
          focusOkButton() {
            this.$refs.okButton.focus();
          },
          handleTimeInputFocus(e) {
            const input = e.target;
            input.focus();
            setTimeout(() => {
              input.setSelectionRange(0, 2);
            }, 1);
          },
          handleTimeInput(e, maxValue, minValue, valueHandler) {
            const input = e.target;
            const { value } = input;
            if (value === "") {
              return;
            }
            const numericValue = Number(value);
            const keyPressed = Number(e.data);
            if (!isNumeric(numericValue)) {
              input.value = this.lastValidValue;
              return;
            }
            if (numericValue > maxValue || numericValue < minValue) {
              if (isNumeric(keyPressed)) {
                if (this.alreadyTriedAnInvalidValue) {
                  input.value = String(keyPressed);
                  input.dispatchEvent(new Event("input"));
                  this.alreadyTriedAnInvalidValue = false;
                  return;
                }
                this.alreadyTriedAnInvalidValue = true;
              }
              input.value = this.lastValidValue;
              return;
            }
            valueHandler(numericValue);
            this.alreadyTriedAnInvalidValue = false;
            this.lastValidValue = value;
          },
          setHours(hours) {
            const newDate = new Date(this.localActiveDate.valueOf());
            newDate.setHours(hours);
            this.localActiveDate = newDate;
          },
          setMinutes(minutes) {
            const newDate = new Date(this.localActiveDate.valueOf());
            newDate.setMinutes(minutes);
            this.localActiveDate = newDate;
          },
          setSeconds(seconds) {
            const newDate = new Date(this.localActiveDate.valueOf());
            newDate.setSeconds(seconds);
            this.localActiveDate = newDate;
          },
          updateSecondsInput() {
            if (!this.showSeconds) {
              return;
            }
            const seconds = this.$refs.seconds;
            if (seconds) {
              seconds.value = this.secondsFormatted;
            }
          },
          updateMinutesInput() {
            const minutes = this.$refs.minutes;
            if (minutes) {
              minutes.value = this.minutesFormatted;
            }
          },
          updateHoursInput() {
            const hours = this.$refs.hours;
            if (hours) {
              hours.value = this.hoursFormatted;
            }
          },
          focus() {
            const timeInput = this.$refs.timeInput;
            if (timeInput) {
              timeInput.focus();
            }
          }
        },
        render(createElement) {
          const subElements = [];
          const label = createElement("label", {
            class: this.getElementCssClass("timepickerTimeLabel")
          }, this.locale.timeLabel);
          const timePickerInputs = [
            createElement("input", {
              ref: "hours",
              class: this.getElementCssClass("timepickerInput"),
              domProps: {
                value: this.hoursFormatted
              },
              attrs: {
                inputmode: "numeric",
                type: "text",
                contenteditable: false
              },
              on: {
                input: (e) => {
                  const maxHours = this.amPm ? 12 : 23;
                  const minHours = this.amPm ? 1 : 0;
                  this.handleTimeInput(e, maxHours, minHours, (hours) => {
                    if (this.amPm) {
                      if (hours === 12) {
                        this.setHours(this.amPmFormatted === this.locale.amPM[1] ? hours : 0);
                      } else {
                        this.setHours(this.amPmFormatted === this.locale.amPM[1] ? hours + 12 : hours);
                      }
                    } else {
                      this.setHours(hours);
                    }
                  });
                },
                blur: (e) => {
                  this.$emit("blur", e);
                  this.$emit("input", this.localActiveDate);
                  this.$nextTick(() => {
                    this.updateHoursInput();
                  });
                },
                focus: (e) => {
                  this.handleTimeInputFocus(e);
                }
              }
            }),
            createElement("span", {
              class: this.getElementCssClass("timepickerTimeSeparator"),
              attrs: {
                contenteditable: false
              }
            }, ":"),
            createElement("input", {
              ref: "minutes",
              class: this.getElementCssClass("timepickerInput"),
              domProps: {
                value: this.minutesFormatted
              },
              attrs: {
                inputmode: "numeric",
                type: "text",
                contenteditable: false
              },
              on: {
                input: (e) => {
                  const maxMinutes = 59;
                  const minMinutes = 0;
                  this.handleTimeInput(e, maxMinutes, minMinutes, this.setMinutes);
                },
                blur: (e) => {
                  this.$emit("blur", e);
                  this.$emit("input", this.localActiveDate);
                  this.$nextTick(() => {
                    this.updateMinutesInput();
                  });
                },
                focus: (e) => {
                  this.handleTimeInputFocus(e);
                }
              }
            })
          ];
          if (this.showSeconds) {
            timePickerInputs.push(createElement("span", {
              class: this.getElementCssClass("timepickerTimeSeparator"),
              attrs: {
                contenteditable: false
              }
            }, ":"));
            timePickerInputs.push(createElement("input", {
              ref: "seconds",
              class: this.getElementCssClass("timepickerInput"),
              domProps: {
                value: this.secondsFormatted
              },
              attrs: {
                inputmode: "numeric",
                type: "text",
                contenteditable: false
              },
              on: {
                input: (e) => {
                  const maxSeconds = 59;
                  const minSeconds = 0;
                  this.handleTimeInput(e, maxSeconds, minSeconds, this.setSeconds);
                },
                blur: (e) => {
                  this.$emit("blur", e);
                  this.$emit("input", this.localActiveDate);
                  this.$nextTick(() => {
                    this.updateSecondsInput();
                  });
                },
                focus: (e) => {
                  this.handleTimeInputFocus(e);
                }
              }
            }));
          }
          const timePickerElements = [
            createElement("div", {
              ref: "timeInput",
              class: this.getElementCssClass("timepickerTimeFieldsWrapper"),
              style: {
                caretColor: "transparent"
              },
              attrs: {
                tabindex: 0,
                inputmode: "numeric",
                contenteditable: true
              },
              on: {
                keydown: (e) => {
                  if (e.target !== this.$refs.timeInput) {
                    return;
                  }
                  e.preventDefault();
                  const { key } = e;
                  if (key === "Enter") {
                    this.focusNextElementFullTimeSelector();
                  } else if (key === "Backspace") {
                    this.timeInputKeys.pop();
                  }
                  if (isNumeric(key)) {
                    this.timeInputKeys.push(key);
                  }
                },
                blur: this.handleFullTimeBlur
              }
            }, timePickerInputs)
          ];
          if (this.amPm) {
            timePickerElements.push(createElement(TToggle, {
              ref: "amPm",
              props: {
                model: this.amPmFormatted,
                value: this.locale.amPM[1],
                uncheckedValue: this.locale.amPM[0],
                checkedPlaceholder: this.locale.amPM[0],
                uncheckedPlaceholder: this.locale.amPM[1],
                checkedLabel: this.locale.amPM[1],
                uncheckedLabel: this.locale.amPM[0],
                fixedClasses: {
                  wrapper: "",
                  wrapperChecked: "",
                  wrapperDisabled: "",
                  wrapperCheckedDisabled: "",
                  button: "",
                  buttonChecked: "",
                  checkedPlaceholder: "",
                  uncheckedPlaceholder: ""
                },
                classes: {
                  wrapper: this.getElementCssClass("timepickerAmPmWrapper"),
                  wrapperChecked: this.getElementCssClass("timepickerAmPmWrapperChecked"),
                  wrapperDisabled: this.getElementCssClass("timepickerAmPmWrapperDisabled"),
                  wrapperCheckedDisabled: this.getElementCssClass("timepickerAmPmWrapperCheckedDisabled"),
                  button: this.getElementCssClass("timepickerAmPmButton"),
                  buttonChecked: this.getElementCssClass("timepickerAmPmButtonChecked"),
                  checkedPlaceholder: this.getElementCssClass("timepickerAmPmCheckedPlaceholder"),
                  uncheckedPlaceholder: this.getElementCssClass("timepickerAmPmUncheckedPlaceholder")
                }
              },
              on: {
                blur: (e) => this.$emit("blur", e),
                input: (amOrPM) => {
                  const formattedDate = this.format(new Date(this.localActiveDate.valueOf()), "Y-m-d G:i:S");
                  const newActiveDate = this.parse(`${formattedDate} ${amOrPM}`, "Y-m-d G:i:S K");
                  this.$emit("input", newActiveDate);
                },
                keydown: (e) => {
                  const { key } = e;
                  if (key === "Enter") {
                    this.focusOkButton();
                  }
                }
              }
            }));
          }
          timePickerElements.push(createElement("a", {
            ref: "okButton",
            attrs: {
              href: "#"
            },
            class: this.getElementCssClass("timepickerOkButton"),
            on: {
              blur: (e) => this.$emit("blur", e),
              click: (e) => {
                e.preventDefault();
                this.$emit("submit", this.localActiveDate);
              }
            }
          }, this.locale.okLabel));
          const timePickerWrapper = createElement("div", {
            class: this.getElementCssClass("timepickerTimeWrapper")
          }, timePickerElements);
          subElements.push(label);
          subElements.push(timePickerWrapper);
          return createElement("div", {
            class: this.getElementCssClass("timepickerWrapper")
          }, subElements);
        }
      });
      const getInitialActiveDate = (localValue, initialDate, dateFormat, parse, amPm, initialTime) => {
        if (Array.isArray(localValue) && localValue.length) {
          return localValue[localValue.length - 1];
        }
        if (localValue instanceof Date) {
          return localValue;
        }
        const activeDate = parse(initialDate, dateFormat) || new Date();
        if (initialTime) {
          const parsedDateWithTime = parse(initialTime, amPm ? "G:i:S K" : "H:i:S");
          if (parsedDateWithTime) {
            activeDate.setHours(parsedDateWithTime.getHours());
            activeDate.setMinutes(parsedDateWithTime.getMinutes());
            activeDate.setSeconds(parsedDateWithTime.getSeconds());
          }
        }
        return activeDate;
      };
      const TDatepicker = HtmlInput.extend({
        name: "TDatepicker",
        props: {
          value: {
            type: [Date, String, Number, Array],
            default: null
          },
          placeholder: {
            type: String,
            default: void 0
          },
          inputName: {
            type: String,
            default: void 0
          },
          weekStart: {
            type: Number,
            default: 0
          },
          monthsPerView: {
            type: Number,
            default: 1,
            validator(value) {
              return value >= 1;
            }
          },
          lang: {
            type: String,
            default: "en"
          },
          locale: {
            type: Object,
            default: () => English
          },
          locales: {
            type: Object,
            default: () => ({})
          },
          dateFormat: {
            type: String,
            default: "Y-m-d"
          },
          userFormat: {
            type: String,
            default: "F j, Y"
          },
          dateFormatter: {
            type: Function,
            default: void 0
          },
          dateParser: {
            type: Function,
            default: void 0
          },
          closeOnSelect: {
            type: Boolean,
            default: true
          },
          showDaysForOtherMonth: {
            type: Boolean,
            default: true
          },
          show: {
            type: Boolean,
            default: false
          },
          inline: {
            type: Boolean,
            default: false
          },
          initialView: {
            type: String,
            default: CalendarView.Day,
            validator(value) {
              return [CalendarView.Day, CalendarView.Month, CalendarView.Year].includes(value);
            }
          },
          yearsPerView: {
            type: Number,
            default: 12
          },
          disabledDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          highlightDates: {
            type: [Date, Array, Function, String],
            default: void 0
          },
          maxDate: {
            type: [Date, String],
            default: void 0
          },
          minDate: {
            type: [Date, String],
            default: void 0
          },
          initialDate: {
            type: [Date, String],
            default: void 0
          },
          initialTime: {
            type: String,
            default: void 0
          },
          conjunction: {
            type: String,
            default: ","
          },
          multiple: {
            type: Boolean,
            default: false
          },
          range: {
            type: Boolean,
            default: false
          },
          clearable: {
            type: Boolean,
            default: true
          },
          datepicker: {
            type: Boolean,
            default: true
          },
          timepicker: {
            type: Boolean,
            default: false
          },
          amPm: {
            type: Boolean,
            default: false
          },
          showSeconds: {
            type: Boolean,
            default: false
          },
          classes: {
            type: Object,
            default: () => ({
              wrapper: "flex flex-col",
              dropdownWrapper: "relative z-10",
              dropdown: "origin-top-left absolute rounded shadow bg-white overflow-hidden mt-1",
              enterClass: "opacity-0 scale-95",
              enterActiveClass: "transition transform ease-out duration-100",
              enterToClass: "opacity-100 scale-100",
              leaveClass: "opacity-100 scale-100",
              leaveActiveClass: "transition transform ease-in duration-75",
              leaveToClass: "opacity-0 scale-95",
              inlineWrapper: "",
              inlineViews: "rounded bg-white border mt-1 inline-flex flex-col",
              inputWrapper: "",
              input: "block w-full px-3 py-2 text-black placeholder-gray-400 transition duration-100 ease-in-out bg-white border border-gray-300 rounded shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed",
              clearButton: "hover:bg-gray-100 rounded transition duration-100 ease-in-out text-gray-600",
              clearButtonIcon: "",
              viewGroup: "",
              view: "",
              navigator: "pt-2 px-3",
              navigatorViewButton: "transition ease-in-out duration-100 inline-flex cursor-pointer rounded-full px-2 py-1 -ml-1 hover:bg-gray-100",
              navigatorViewButtonIcon: "fill-current text-gray-400",
              navigatorViewButtonBackIcon: "fill-current text-gray-400",
              navigatorViewButtonMonth: "text-gray-700 font-semibold",
              navigatorViewButtonYear: "text-gray-500 ml-1",
              navigatorViewButtonYearRange: "text-gray-500 ml-1",
              navigatorLabel: "py-1",
              navigatorLabelMonth: "text-gray-700 font-semibold",
              navigatorLabelYear: "text-gray-500 ml-1",
              navigatorPrevButton: "transition ease-in-out duration-100 inline-flex cursor-pointer hover:bg-gray-100 rounded-full p-1 ml-2 ml-auto disabled:opacity-50 disabled:cursor-not-allowed",
              navigatorNextButton: "transition ease-in-out duration-100 inline-flex cursor-pointer hover:bg-gray-100 rounded-full p-1 -mr-1 disabled:opacity-50 disabled:cursor-not-allowed",
              navigatorPrevButtonIcon: "text-gray-400",
              navigatorNextButtonIcon: "text-gray-400",
              calendarWrapper: "px-3 py-2",
              calendarHeaderWrapper: "",
              calendarHeaderWeekDay: "uppercase text-xs text-gray-500 w-8 h-8 flex items-center justify-center",
              calendarDaysWrapper: "",
              calendarDaysDayWrapper: "w-full h-8 flex flex-shrink-0 items-center",
              otherMonthDay: "text-sm rounded-full w-8 h-8 mx-auto hover:bg-blue-100 text-gray-400 disabled:opacity-50 disabled:cursor-not-allowed",
              emptyDay: "",
              inRangeFirstDay: "text-sm bg-blue-500 text-white w-full h-8 rounded-l-full",
              inRangeLastDay: "text-sm bg-blue-500 text-white w-full h-8 rounded-r-full",
              inRangeDay: "text-sm bg-blue-200 w-full h-8 disabled:opacity-50 disabled:cursor-not-allowed",
              selectedDay: "text-sm rounded-full w-8 h-8 mx-auto bg-blue-500 text-white disabled:opacity-50 disabled:cursor-not-allowed",
              activeDay: "text-sm rounded-full bg-blue-100 w-8 h-8 mx-auto disabled:opacity-50 disabled:cursor-not-allowed",
              highlightedDay: "text-sm rounded-full bg-blue-200 w-8 h-8 mx-auto disabled:opacity-50 disabled:cursor-not-allowed",
              day: "text-sm rounded-full w-8 h-8 mx-auto hover:bg-blue-100 disabled:opacity-50 disabled:cursor-not-allowed",
              today: "text-sm rounded-full w-8 h-8 mx-auto hover:bg-blue-100 disabled:opacity-50 disabled:cursor-not-allowed border border-blue-500",
              monthWrapper: "px-3 py-2",
              selectedMonth: "text-sm rounded w-full h-12 mx-auto bg-blue-500 text-white",
              activeMonth: "text-sm rounded w-full h-12 mx-auto bg-blue-100",
              month: "text-sm rounded w-full h-12 mx-auto hover:bg-blue-100",
              yearWrapper: "px-3 py-2",
              year: "text-sm rounded w-full h-12 mx-auto hover:bg-blue-100",
              selectedYear: "text-sm rounded w-full h-12 mx-auto bg-blue-500 text-white",
              activeYear: "text-sm rounded w-full h-12 mx-auto bg-blue-100",
              timepickerWrapper: "flex items-center px-4 py-2 space-x-2",
              timepickerTimeWrapper: "flex items-center space-x-2",
              timepickerTimeFieldsWrapper: "bg-gray-100 rounded-md w-full text-right flex items-center border border-gray-100 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
              timepickerOkButton: "text-blue-600 text-sm uppercase font-semibold transition duration-100 ease-in-out border border-transparent focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 rounded cursor-pointer",
              timepickerInput: "text-center w-8 border-transparent bg-transparent p-0 h-6 text-sm transition duration-100 ease-in-out border border-transparent focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 rounded",
              timepickerTimeLabel: "flex-grow text-sm text-gray-500",
              timepickerAmPmWrapper: "relative inline-flex flex-shrink-0 transition duration-200 ease-in-out bg-gray-100 border border-transparent rounded cursor-pointer focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
              timepickerAmPmWrapperChecked: "relative inline-flex flex-shrink-0 transition duration-200 ease-in-out bg-gray-100 border border-transparent rounded cursor-pointer focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
              timepickerAmPmWrapperDisabled: "relative inline-flex flex-shrink-0 transition duration-200 ease-in-out opacity-50 cursor-not-allowed",
              timepickerAmPmWrapperCheckedDisabled: "relative inline-flex flex-shrink-0 transition duration-200 ease-in-out opacity-50 cursor-not-allowed",
              timepickerAmPmButton: "absolute flex items-center justify-center w-6 h-6 text-xs text-gray-800 transition duration-200 ease-in-out transform translate-x-0 bg-white rounded shadow",
              timepickerAmPmButtonChecked: "absolute flex items-center justify-center w-6 h-6 text-xs text-gray-800 transition duration-200 ease-in-out transform translate-x-full bg-white rounded shadow",
              timepickerAmPmCheckedPlaceholder: "flex items-center justify-center w-6 h-6 text-xs text-gray-500 rounded-sm",
              timepickerAmPmUncheckedPlaceholder: "flex items-center justify-center w-6 h-6 text-xs text-gray-500 rounded-sm"
            })
          },
          fixedClasses: {
            type: Object,
            default: () => ({
              navigator: "flex",
              navigatorViewButton: "flex items-center",
              navigatorViewButtonIcon: "flex-shrink-0 h-5 w-5",
              navigatorViewButtonBackIcon: "flex-shrink-0 h-5 w-5",
              navigatorLabel: "flex items-center py-1",
              navigatorPrevButtonIcon: "h-6 w-6 inline-flex",
              navigatorNextButtonIcon: "h-6 w-6 inline-flex",
              inputWrapper: "relative",
              viewGroup: "inline-flex flex-wrap",
              view: "w-64",
              calendarDaysWrapper: "grid grid-cols-7",
              calendarHeaderWrapper: "grid grid-cols-7",
              monthWrapper: "grid grid-cols-4",
              yearWrapper: "grid grid-cols-4",
              clearButton: "flex flex-shrink-0 items-center justify-center absolute right-0 top-0 m-2 h-6 w-6",
              clearButtonIcon: "fill-current h-3 w-3"
            })
          }
        },
        data() {
          const currentLocale = extractLocaleFromProps(this.lang, this.locales, this.locale);
          const dateFormatter = this.dateFormatter;
          const parse = buildDateParser(currentLocale, this.dateParser);
          const format = buildDateFormatter(currentLocale, dateFormatter);
          const formatNative = !dateFormatter ? format : buildDateFormatter(currentLocale);
          let localValue = this.multiple || this.range ? [] : null;
          if (Array.isArray(this.value)) {
            localValue = this.value.map((value) => parse(value, this.dateFormat) || null).filter((value) => !!value);
          } else {
            localValue = parse(this.value, this.dateFormat) || localValue;
          }
          const formatedDate = Array.isArray(localValue) ? localValue.map((d) => format(d, this.dateFormat)) : format(localValue, this.dateFormat);
          const userFormatedDate = Array.isArray(localValue) ? localValue.map((d) => format(d, this.userFormat)) : format(localValue, this.userFormat);
          const activeDate = getInitialActiveDate(localValue, this.initialDate, this.dateFormat, parse, this.amPm, this.initialTime);
          const currentView = this.initialView;
          let dateWithoutTime = null;
          if (this.timepicker) {
            dateWithoutTime = Array.isArray(localValue) ? localValue[0] : localValue;
          }
          return {
            localValue,
            formatedDate,
            userFormatedDate,
            activeDate,
            shown: this.show,
            showActiveDate: false,
            currentView,
            parse,
            format,
            formatNative,
            currentLocale,
            hasFocus: false,
            dateWithoutTime,
            timeWithoutDate: null
          };
        },
        computed: {
          visibleRange() {
            const start = new Date(this.activeDate.valueOf());
            const end = new Date(this.activeDate.valueOf());
            start.setDate(1);
            end.setMonth(end.getMonth() + this.monthsPerView, 0);
            return [start, end];
          },
          latestDate() {
            if (Array.isArray(this.localValue)) {
              if (this.localValue.length) {
                return this.localValue[this.localValue.length - 1] || null;
              }
              return null;
            }
            return this.localValue;
          },
          currentValueIsInTheView() {
            if (this.latestDate) {
              const [start, end] = this.visibleRange;
              return compareDates(end, this.latestDate) >= 0 && compareDates(this.latestDate, start) >= 0;
            }
            return true;
          }
        },
        watch: {
          shown(shown) {
            this.$emit("update:show", shown);
          },
          activeDate(activeDate) {
            this.$emit("active-change", activeDate);
          },
          formatedDate(formatedDate) {
            this.$emit("input", formatedDate);
            this.$emit("change", formatedDate);
          },
          userFormatedDate(userFormatedDate) {
            this.$emit("user-date-changed", userFormatedDate);
          },
          localValue(localValue) {
            if (this.monthsPerView === 1 || !this.currentValueIsInTheView) {
              this.resetActiveDate(localValue);
            }
            this.refreshFormattedDate();
          },
          value(value) {
            if (Array.isArray(value)) {
              const localValue = value.map((v) => this.parse(v, this.dateFormat) || null).filter((v) => !!v);
              if (!isEqual__default["default"](localValue, this.localValue)) {
                this.localValue = localValue;
              }
            } else {
              this.localValue = this.parse(value, this.dateFormat) || (this.multiple || this.range ? [] : null);
            }
          },
          dateParser() {
            this.refreshParser();
          },
          dateFormatter() {
            this.refreshFormatter();
          },
          lang() {
            this.refreshCurrentLocale();
          },
          locale() {
            this.refreshCurrentLocale();
          },
          locales: {
            handler() {
              this.refreshCurrentLocale();
            },
            deep: true
          }
        },
        methods: {
          refreshFormattedDate() {
            const formatedDate = Array.isArray(this.localValue) ? this.localValue.map((d) => this.format(d, this.dateFormat)) : this.format(this.localValue, this.dateFormat);
            const userFormatedDate = Array.isArray(this.localValue) ? this.localValue.map((d) => this.format(d, this.userFormat)) : this.format(this.localValue, this.userFormat);
            this.formatedDate = formatedDate;
            this.userFormatedDate = userFormatedDate;
          },
          refreshCurrentLocale() {
            this.currentLocale = extractLocaleFromProps(this.lang, this.locales, this.locale);
            this.refreshParser();
            this.refreshFormatter();
            this.refreshFormattedDate();
          },
          refreshParser() {
            const parse = buildDateParser(this.currentLocale, this.dateParser);
            this.parse = parse;
          },
          refreshFormatter() {
            const dateFormatter = this.dateFormatter;
            const format = buildDateFormatter(this.currentLocale, dateFormatter);
            const formatNative = !dateFormatter ? format : buildDateFormatter(this.currentLocale);
            this.format = format;
            this.formatNative = formatNative;
          },
          focus(options) {
            const wrapper = this.$el;
            const input = wrapper.querySelector("input[type=text]");
            if (!input) {
              throw new Error("Input not found");
            }
            input.focus(options);
          },
          doHide() {
            const dropdown = this.getDropdown();
            if (dropdown) {
              dropdown.doHide();
            }
          },
          doShow() {
            const dropdown = this.getDropdown();
            if (dropdown) {
              dropdown.doShow();
            }
          },
          toggle() {
            const dropdown = this.getDropdown();
            if (dropdown) {
              dropdown.doToggle();
            }
          },
          arrowKeyHandler(e) {
            e.preventDefault();
            this.showActiveDate = true;
            if (!this.inline && !this.shown) {
              this.doShow();
              return;
            }
            let newActiveDate;
            if (this.currentView === CalendarView.Day) {
              if (e.keyCode === Key$1.DOWN) {
                newActiveDate = addDays(this.activeDate, 7);
              } else if (e.keyCode === Key$1.LEFT) {
                newActiveDate = addDays(this.activeDate, -1);
              } else if (e.keyCode === Key$1.UP) {
                newActiveDate = addDays(this.activeDate, -7);
              } else if (e.keyCode === Key$1.RIGHT) {
                newActiveDate = addDays(this.activeDate, 1);
              }
            } else if (this.currentView === CalendarView.Month) {
              if (e.keyCode === Key$1.DOWN) {
                newActiveDate = addMonths(this.activeDate, 4);
              } else if (e.keyCode === Key$1.LEFT) {
                newActiveDate = addMonths(this.activeDate, -1);
              } else if (e.keyCode === Key$1.UP) {
                newActiveDate = addMonths(this.activeDate, -4);
              } else if (e.keyCode === Key$1.RIGHT) {
                newActiveDate = addMonths(this.activeDate, 1);
              }
            } else if (this.currentView === CalendarView.Year) {
              if (e.keyCode === Key$1.DOWN) {
                newActiveDate = addYears(this.activeDate, 4);
              } else if (e.keyCode === Key$1.LEFT) {
                newActiveDate = addYears(this.activeDate, -1);
              } else if (e.keyCode === Key$1.UP) {
                newActiveDate = addYears(this.activeDate, -4);
              } else if (e.keyCode === Key$1.RIGHT) {
                newActiveDate = addYears(this.activeDate, 1);
              }
            }
            if (newActiveDate && !dateIsOutOfRange(newActiveDate, this.minDate, this.maxDate, this.parse, this.dateFormat)) {
              this.activeDate = newActiveDate;
            }
          },
          focusTimePicker() {
            this.$refs.timePicker.focus();
          },
          inputDateHandler(date) {
            this.dateWithoutTime = date;
            this.dateTimeInputHandler();
          },
          inputTimeHandler(date) {
            this.timeWithoutDate = date;
            if (this.datepicker) {
              this.dateTimeInputHandler();
            } else {
              this.inputHandler(date);
            }
          },
          dateTimeInputHandler() {
            if (this.dateWithoutTime === null || this.timeWithoutDate === null) {
              if (this.timeWithoutDate === null) {
                this.focusTimePicker();
              } else if (this.dateWithoutTime === null) {
                this.focus();
              }
              return;
            }
            const { dateWithoutTime, timeWithoutDate } = this;
            const dateTime = new Date(dateWithoutTime.getFullYear(), dateWithoutTime.getMonth(), dateWithoutTime.getDate(), timeWithoutDate.getHours(), timeWithoutDate.getMinutes(), timeWithoutDate.getSeconds());
            this.inputHandler(dateTime);
          },
          inputHandler(newDate) {
            const date = new Date(newDate.valueOf());
            const disabledDates = this.disabledDates;
            if (dayIsPartOfTheConditions(date, disabledDates, this.parse, this.dateFormat) || dateIsOutOfRange(date, this.minDate, this.maxDate, this.parse, this.dateFormat)) {
              return;
            }
            if (this.range) {
              let range2 = [];
              if (!this.localValue || !Array.isArray(this.localValue) || Array.isArray(this.localValue) && (this.localValue.length === 0 || this.localValue.length === 2) || Array.isArray(this.localValue) && this.localValue.length === 1 && this.localValue[0] && this.localValue[0].getTime() > date.getTime()) {
                range2 = [date];
              } else if (this.localValue.length === 1) {
                range2 = [this.localValue[0], date];
              }
              this.localValue = range2;
              if (!this.inline && this.localValue.length === 2 && this.closeOnSelect) {
                this.doHide();
              }
            } else if (Array.isArray(this.localValue)) {
              const index = this.localValue.findIndex((d) => isSameDay(d, date));
              if (index >= 0) {
                this.localValue.splice(index, 1);
              } else {
                this.localValue.push(date);
              }
            } else {
              this.focus();
              this.localValue = date;
            }
            if (!this.inline && this.closeOnSelect && !Array.isArray(this.localValue)) {
              this.doHide();
            }
          },
          inputActiveDateHandler(newDate) {
            this.activeDate = new Date(newDate.valueOf());
          },
          setView(newView) {
            this.currentView = newView;
            this.focus();
          },
          resetView() {
            if (this.currentView === CalendarView.Month) {
              this.setView(CalendarView.Day);
            } else if (this.currentView === CalendarView.Year) {
              this.setView(CalendarView.Month);
            } else {
              this.setView(CalendarView.Day);
            }
          },
          enterHandler(e) {
            e.preventDefault();
            if (!this.inline && !this.shown) {
              this.doShow();
            } else if (this.showActiveDate) {
              if (this.currentView === CalendarView.Day) {
                if (this.timepicker) {
                  this.inputDateHandler(new Date(this.activeDate.valueOf()));
                } else {
                  this.inputHandler(new Date(this.activeDate.valueOf()));
                }
              } else {
                this.resetView();
              }
            }
          },
          escapeHandler(e) {
            e.preventDefault();
            const dropdown = this.getDropdown();
            if (dropdown) {
              dropdown.escapeHandler(e);
            }
          },
          spaceHandler(e) {
            e.preventDefault();
            this.toggle();
          },
          getDropdown() {
            return this.$refs.dropdown;
          },
          resetInitialState() {
            this.shown = false;
            this.currentView = this.initialView;
            this.showActiveDate = false;
            if (this.timepicker) {
              this.dateWithoutTime = Array.isArray(this.localValue) ? this.localValue[0] : this.localValue;
            } else {
              this.dateWithoutTime = null;
            }
            this.timeWithoutDate = null;
            this.resetActiveDate(this.localValue);
          },
          resetActiveDate(localValue) {
            this.activeDate = getInitialActiveDate(localValue, this.initialDate, this.dateFormat, this.parse, this.amPm, this.initialTime);
          },
          clearHandler() {
            if (this.multiple || this.range) {
              this.localValue = [];
            } else {
              this.localValue = null;
            }
            this.resetActiveDate(this.localValue);
          },
          focusHandler(e) {
            this.hasFocus = true;
            this.$emit("focus", e);
          },
          blurHandler(e) {
            this.hasFocus = false;
            this.$emit("blur", e);
          },
          hideIfFocusOutside(e) {
            const dropdown = this.getDropdown();
            if (dropdown) {
              dropdown.hideIfFocusOutside(e);
            }
          }
        },
        render(createElement) {
          const views = [];
          if (this.datepicker) {
            views.push(createElement(TDatepickerViews, {
              ref: "views",
              props: {
                value: this.localValue,
                activeDate: this.activeDate,
                weekStart: this.weekStart,
                monthsPerView: this.monthsPerView,
                lang: this.lang,
                locale: this.currentLocale,
                getElementCssClass: this.getElementCssClass,
                parse: this.parse,
                format: this.format,
                formatNative: this.formatNative,
                dateFormat: this.dateFormat,
                userFormat: this.userFormat,
                initialView: this.initialView,
                currentView: this.currentView,
                yearsPerView: this.yearsPerView,
                showActiveDate: this.showActiveDate,
                disabledDates: this.disabledDates,
                highlightDates: this.highlightDates,
                minDate: this.minDate,
                maxDate: this.maxDate,
                range: this.range,
                showDaysForOtherMonth: this.showDaysForOtherMonth,
                datepicker: this.datepicker,
                timepicker: this.timepicker,
                dateWithoutTime: this.dateWithoutTime
              },
              scopedSlots: this.$scopedSlots,
              on: {
                input: this.inputHandler,
                "input-date": this.inputDateHandler,
                "input-time": this.inputTimeHandler,
                "input-active-date": this.inputActiveDateHandler,
                "update-view": this.setView,
                "reset-view": this.resetView,
                "reset-focus": this.focus
              }
            }));
          }
          if (this.timepicker && this.currentView === CalendarView.Day) {
            views.push(createElement(TDatepickerTimeSelector, {
              ref: "timePicker",
              props: {
                parse: this.parse,
                format: this.format,
                amPm: this.amPm,
                showSeconds: this.showSeconds,
                activeDate: this.activeDate,
                locale: this.currentLocale,
                getElementCssClass: this.getElementCssClass
              },
              on: {
                input: this.inputActiveDateHandler,
                submit: this.inputTimeHandler,
                blur: this.hideIfFocusOutside
              }
            }));
          }
          const triggerSettings = {
            ref: "trigger",
            props: {
              id: this.id,
              name: this.name,
              inputName: this.inputName,
              disabled: this.disabled,
              readonly: this.readonly,
              autofocus: this.autofocus,
              required: this.required,
              placeholder: this.placeholder,
              tabindex: this.tabindex,
              userFormatedDate: this.userFormatedDate,
              formatedDate: this.formatedDate,
              conjunction: this.conjunction,
              multiple: this.multiple,
              range: this.range,
              clearable: this.clearable,
              locale: this.currentLocale,
              value: this.localValue,
              activeDate: this.activeDate,
              hasFocus: this.hasFocus,
              getElementCssClass: this.getElementCssClass
            },
            scopedSlots: this.$scopedSlots,
            on: {
              clear: this.clearHandler,
              focus: this.focusHandler,
              blur: this.blurHandler,
              keydown: (e) => {
                if ([Key$1.LEFT, Key$1.UP, Key$1.RIGHT, Key$1.DOWN].includes(e.keyCode) && this.datepicker) {
                  this.arrowKeyHandler(e);
                } else if (e.keyCode === Key$1.ENTER) {
                  this.enterHandler(e);
                } else if (e.keyCode === Key$1.ESC) {
                  this.escapeHandler(e);
                } else if (e.keyCode === Key$1.SPACE) {
                  this.spaceHandler(e);
                }
                if (isNumeric(e.key)) {
                  this.focusTimePicker();
                }
                this.$emit("keydown", e);
              }
            }
          };
          if (this.inline) {
            return createElement("div", {
              class: this.getElementCssClass("inlineWrapper")
            }, [
              createElement(TDatepickerTrigger, triggerSettings),
              createElement("div", {
                class: this.getElementCssClass("inlineViews")
              }, views)
            ]);
          }
          return createElement(TDropdown, {
            ref: "dropdown",
            props: {
              fixedClasses: void 0,
              classes: {
                wrapper: this.getElementCssClass("wrapper"),
                dropdownWrapper: this.getElementCssClass("dropdownWrapper"),
                dropdown: this.getElementCssClass("dropdown"),
                enterClass: this.getElementCssClass("enterClass"),
                enterActiveClass: this.getElementCssClass("enterActiveClass"),
                enterToClass: this.getElementCssClass("enterToClass"),
                leaveClass: this.getElementCssClass("leaveClass"),
                leaveActiveClass: this.getElementCssClass("leaveActiveClass"),
                leaveToClass: this.getElementCssClass("leaveToClass")
              },
              show: this.show
            },
            on: {
              hidden: () => {
                this.$emit("hidden");
                this.resetInitialState();
              },
              shown: () => {
                this.$emit("shown");
                this.shown = true;
                if (this.timepicker && !this.datepicker) {
                  this.$nextTick(() => {
                    this.focusTimePicker();
                  });
                }
              }
            },
            scopedSlots: {
              trigger: (props) => {
                const settings = cloneDeep__default["default"](triggerSettings);
                settings.props = Object.assign(Object.assign({}, settings.props), {
                  hideIfFocusOutside: props.hideIfFocusOutside,
                  show: props.show
                });
                return [
                  createElement(TDatepickerTrigger, settings)
                ];
              }
            }
          }, views);
        }
      });
      var HideReason;
      (function(HideReason2) {
        HideReason2["Outside"] = "outside";
        HideReason2["Close"] = "close";
        HideReason2["Esc"] = "esc";
        HideReason2["Cancel"] = "cancel";
        HideReason2["Ok"] = "ok";
        HideReason2["Method"] = "method";
        HideReason2["Value"] = "value";
      })(HideReason || (HideReason = {}));
      var DialogType;
      (function(DialogType2) {
        DialogType2["Alert"] = "alert";
        DialogType2["Confirm"] = "confirm";
        DialogType2["Prompt"] = "prompt";
      })(DialogType || (DialogType = {}));
      const uniqid = () => Math.random().toString(36).substring(7);
      const TDialogOverlayWrapperTransitionDialogContentInput = Vue__default["default"].extend({
        name: "TDialogOverlayWrapperTransitionDialogContentInput",
        props: {
          getElementCssClass: {
            type: Function,
            required: true
          },
          inputAttributes: {
            type: Object,
            default: void 0
          },
          inputType: {
            type: String,
            required: true
          },
          inputValue: {
            type: [String, Array],
            default: void 0
          },
          inputPlaceholder: {
            type: String,
            default: void 0
          },
          inputOptions: {
            type: [Array, Object],
            default: void 0
          }
        },
        data() {
          return {
            errorMessage: null
          };
        },
        mounted() {
          this.inputHandler();
        },
        methods: {
          getInputValue() {
            const input = this.$refs.input;
            if (!input) {
              return void 0;
            }
            const inputName = input.name;
            if (input.type === "radio") {
              const checkedRadio = this.$refs.inputWrapper.querySelector(`input[name="${inputName}"]:checked`);
              return checkedRadio ? checkedRadio.value : null;
            }
            if (input.type === "checkbox") {
              if (this.inputOptions) {
                const checkedCheckboxes = this.$refs.inputWrapper.querySelectorAll(`input[name="${inputName}"]:checked`);
                const inititalValue = Array.from(checkedCheckboxes).map((checkbox) => checkbox.value);
                return inititalValue;
              }
              return input.checked ? input.value : null;
            }
            return input.value;
          },
          inputHandler() {
            this.errorMessage = null;
            const inputValue = this.getInputValue();
            this.$emit("input", inputValue);
          }
        },
        render(createElement) {
          let input;
          if (this.inputType === "select") {
            const options = normalizeOptions(this.inputOptions || []).map((option) => {
              const isSelected = this.inputValue === option.value;
              return createElement("option", {
                domProps: {
                  value: option.value,
                  selected: isSelected
                }
              }, String(option.text));
            });
            input = createElement("select", {
              class: this.getElementCssClass("select"),
              ref: "input",
              attrs: Object.assign({ name: "input" }, this.inputAttributes),
              on: {
                change: this.inputHandler
              }
            }, options);
          } else if (this.inputType === "radio") {
            input = normalizeOptions(this.inputOptions || []).map((option) => {
              const isChecked2 = this.inputValue === option.value;
              return createElement("label", {
                class: this.getElementCssClass("radioWrapper"),
                attrs: {
                  for: `input-${String(option.value)}`
                }
              }, [
                createElement("input", {
                  class: this.getElementCssClass("radio"),
                  ref: "input",
                  attrs: Object.assign({ type: "radio", name: "input", id: `input-${String(option.value)}`, value: option.value, checked: isChecked2 }, this.inputAttributes),
                  on: {
                    change: this.inputHandler
                  }
                }),
                createElement("span", {
                  class: this.getElementCssClass("radioText")
                }, String(option.text))
              ]);
            });
          } else if (this.inputType === "checkbox") {
            if (this.inputOptions) {
              input = normalizeOptions(this.inputOptions || []).map((option) => {
                const isChecked2 = Array.isArray(this.inputValue) ? this.inputValue.includes(option.value) : this.inputValue === option.value;
                return createElement("label", {
                  class: this.getElementCssClass("checkboxWrapper"),
                  attrs: {
                    for: `input-${String(option.value)}`
                  }
                }, [
                  createElement("input", {
                    class: this.getElementCssClass("checkbox"),
                    ref: "input",
                    attrs: Object.assign({ type: "checkbox", name: "input[]", id: `input-${String(option.value)}`, value: option.value, checked: isChecked2 }, this.inputAttributes),
                    on: {
                      change: this.inputHandler
                    }
                  }),
                  createElement("span", {
                    class: this.getElementCssClass("checkboxText")
                  }, String(option.text))
                ]);
              });
            } else {
              const id = uniqid();
              input = createElement("label", {
                class: this.getElementCssClass("checkboxWrapper"),
                attrs: {
                  for: `input-${id}`
                }
              }, [
                createElement("input", {
                  class: this.getElementCssClass("checkbox"),
                  ref: "input",
                  attrs: Object.assign({ type: "checkbox", name: "input", id: `input-${id}`, value: this.inputValue }, this.inputAttributes),
                  on: {
                    change: this.inputHandler
                  }
                }),
                createElement("span", {
                  class: this.getElementCssClass("checkboxText")
                }, this.inputPlaceholder ? String(this.inputPlaceholder) : "")
              ]);
            }
          } else {
            input = createElement("input", {
              class: this.getElementCssClass("input"),
              ref: "input",
              domProps: {
                value: this.inputValue
              },
              attrs: Object.assign({ name: "input", type: this.inputType, placeholder: this.inputPlaceholder }, this.inputAttributes),
              on: {
                input: this.inputHandler
              }
            });
          }
          return createElement("div", {
            ref: "inputWrapper",
            class: this.getElementCssClass("inputWrapper")
          }, Array.isArray(input) ? input : [input]);
        }
      });
      const TDialogOverlayWrapperTransitionDialogContent = Vue__default["default"].extend({
        name: "TDialogOverlayWrapperTransitionDialogContent",
        props: {
          getElementCssClass: {
            type: Function,
            required: true
          },
          titleTag: {
            type: String,
            required: true
          },
          title: {
            type: String,
            default: void 0
          },
          textTag: {
            type: String,
            required: true
          },
          text: {
            type: String,
            default: void 0
          },
          type: {
            type: String,
            required: true
          },
          inputAttributes: {
            type: Object,
            default: void 0
          },
          inputType: {
            type: String,
            required: true
          },
          inputValue: {
            type: [String, Array],
            default: void 0
          },
          inputPlaceholder: {
            type: String,
            default: void 0
          },
          inputOptions: {
            type: [Array, Object],
            default: void 0
          },
          errorMessage: {
            type: String,
            required: true
          }
        },
        render(createElement) {
          const subElements = [];
          if (this.title || this.$scopedSlots.title) {
            if (this.$scopedSlots.title) {
              subElements.push(createElement("div", {
                class: this.getElementCssClass("titleWrapper")
              }, [
                this.$scopedSlots.title({ class: this.getElementCssClass("title") })
              ]));
            } else {
              subElements.push(createElement("div", {
                class: this.getElementCssClass("titleWrapper")
              }, [
                createElement(this.titleTag, {
                  class: this.getElementCssClass("title")
                }, this.title || "")
              ]));
            }
          }
          if (this.$slots.default) {
            subElements.push(createElement("div", {
              class: this.getElementCssClass("textWrapper")
            }, this.$slots.default));
          } else if (this.text) {
            subElements.push(createElement("div", {
              class: this.getElementCssClass("textWrapper")
            }, this.text ? [
              createElement(this.textTag, {
                class: this.getElementCssClass("text")
              }, this.text)
            ] : void 0));
          }
          if (this.type === DialogType.Prompt) {
            subElements.push(createElement(TDialogOverlayWrapperTransitionDialogContentInput, {
              props: {
                getElementCssClass: this.getElementCssClass,
                inputAttributes: this.inputAttributes,
                inputType: this.inputType,
                inputValue: this.inputValue,
                inputOptions: this.inputOptions,
                inputPlaceholder: this.inputPlaceholder
              },
              on: {
                input: (val) => this.$emit("input", val)
              }
            }));
          }
          if (this.errorMessage && typeof this.errorMessage === "string") {
            subElements.push(createElement("div", {
              class: this.getElementCssClass("errorMessage")
            }, this.errorMessage));
          }
          return createElement("div", {
            class: this.getElementCssClass("content")
          }, subElements);
        }
      });
      var IconName;
      (function(IconName2) {
        IconName2["Success"] = "success";
        IconName2["Error"] = "error";
        IconName2["Warning"] = "warning";
        IconName2["Info"] = "info";
        IconName2["Question"] = "question";
      })(IconName || (IconName = {}));
      function getHtmlSvgPath(iconName) {
        if (!iconName) {
          return void 0;
        }
        const icons = {};
        icons[IconName.Success] = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>';
        icons[IconName.Error] = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>';
        icons[IconName.Warning] = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>';
        icons[IconName.Info] = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>';
        icons[IconName.Question] = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>';
        return icons[iconName];
      }
      const TDialogOverlayWrapperTransitionDialogIcon = Vue__default["default"].extend({
        name: "TDialogOverlayWrapperTransitionDialogIcon",
        props: {
          getElementCssClass: {
            type: Function,
            required: true
          },
          icon: {
            type: String,
            default: void 0
          }
        },
        render(createElement) {
          if (this.$scopedSlots.icon) {
            return createElement("div", {
              class: this.getElementCssClass("iconWrapper")
            }, [
              this.$scopedSlots.icon({})
            ]);
          }
          const htmlSvgPath = getHtmlSvgPath(this.icon);
          if (!htmlSvgPath) {
            return createElement();
          }
          return createElement("div", {
            class: this.getElementCssClass("iconWrapper")
          }, [
            createElement("svg", {
              class: this.getElementCssClass("icon"),
              attrs: {
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24",
                xmlns: "http://www.w3.org/2000/svg"
              },
              domProps: {
                innerHTML: htmlSvgPath
              }
            })
          ]);
        }
      });
      const TDialogOverlayWrapperTransitionDialogClose = Vue__default["default"].extend({
        name: "TDialogOverlayWrapperTransitionDialogClose",
        props: {
          getElementCssClass: {
            type: Function,
            required: true
          },
          showCloseButton: {
            type: Boolean,
            required: true
          }
        },
        render(createElement) {
          if (!this.showCloseButton) {
            return createElement();
          }
          if (this.$scopedSlots.closeButton) {
            return createElement("button", {
              class: this.getElementCssClass("close"),
              attrs: {
                type: "button"
              },
              on: {
                click: (e) => this.$emit("dismiss", e)
              }
            }, [
              this.$scopedSlots.closeButton({})
            ]);
          }
          return createElement("button", {
            class: this.getElementCssClass("close"),
            attrs: {
              type: "button"
            },
            on: {
              click: (e) => this.$emit("dismiss", e)
            }
          }, [
            createElement("svg", {
              attrs: {
                fill: "currentColor",
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 20 20"
              },
              class: this.getElementCssClass("closeIcon")
            }, [
              createElement("path", {
                attrs: {
                  "clip-rule": "evenodd",
                  "fill-rule": "evenodd",
                  d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                }
              })
            ])
          ]);
        }
      });
      const TDialogOverlayWrapperTransitionDialogLoader = Vue__default["default"].extend({
        name: "TDialogOverlayWrapperTransitionDialogLoader",
        props: {
          getElementCssClass: {
            type: Function,
            required: true
          },
          busy: {
            type: Boolean,
            required: true
          }
        },
        render(createElement) {
          if (!this.busy) {
            return createElement();
          }
          if (this.$scopedSlots.loader) {
            return createElement("div", {
              class: this.getElementCssClass("busyWrapper")
            }, [
              this.$scopedSlots.loader({})
            ]);
          }
          return createElement("div", {
            class: this.getElementCssClass("busyWrapper")
          }, [
            createElement("svg", {
              attrs: {
                xmlns: "http://www.w3.org/2000/svg",
                width: 32,
                height: 32,
                viewBox: "0 0 32 32"
              },
              class: this.getElementCssClass("busyIcon")
            }, [
              createElement("g", {
                attrs: {
                  transform: "scale(0.03125 0.03125)"
                }
              }, [
                createElement("path", {
                  attrs: {
                    d: "M512 1024c-136.76 0-265.334-53.258-362.040-149.96-96.702-96.706-149.96-225.28-149.96-362.040 0-96.838 27.182-191.134 78.606-272.692 50-79.296 120.664-143.372 204.356-185.3l43 85.832c-68.038 34.084-125.492 86.186-166.15 150.67-41.746 66.208-63.812 142.798-63.812 221.49 0 229.382 186.618 416 416 416s416-186.618 416-416c0-78.692-22.066-155.282-63.81-221.49-40.66-64.484-98.114-116.584-166.15-150.67l43-85.832c83.692 41.928 154.358 106.004 204.356 185.3 51.422 81.558 78.604 175.854 78.604 272.692 0 136.76-53.258 265.334-149.96 362.040-96.706 96.702-225.28 149.96-362.040 149.96z"
                  }
                })
              ])
            ])
          ]);
        }
      });
      const TDialogOverlayWrapperTransitionDialogButtons = Vue__default["default"].extend({
        name: "TDialogOverlayWrapperTransitionDialogButtons",
        props: {
          getElementCssClass: {
            type: Function,
            required: true
          },
          cancelButtonText: {
            type: String,
            required: true
          },
          cancelButtonAriaLabel: {
            type: String,
            default: void 0
          },
          okButtonText: {
            type: String,
            required: true
          },
          okButtonAriaLabel: {
            type: String,
            default: void 0
          },
          type: {
            type: String,
            required: true
          }
        },
        methods: {
          cancel(e) {
            this.$emit("cancel", e);
          },
          ok(e) {
            this.$emit("submit", e);
          }
        },
        render(createElement) {
          const type = this.type;
          if (this.$scopedSlots.buttons) {
            return createElement("div", {
              class: this.getElementCssClass("buttons")
            }, [
              this.$scopedSlots.buttons({
                cancelButtonAriaLabel: this.cancelButtonAriaLabel,
                okButtonAriaLabel: this.okButtonAriaLabel,
                cancelButtonText: this.cancelButtonText,
                okButtonText: this.okButtonText,
                okButtonClass: this.getElementCssClass("okButton"),
                cancelButtonClass: this.getElementCssClass("cancelButton"),
                dialogType: type,
                cancel: this.cancel,
                ok: this.ok
              })
            ]);
          }
          const subElements = [];
          const buttons = {
            cancel: createElement("button", {
              attrs: {
                type: "button",
                "aria-label": this.cancelButtonAriaLabel
              },
              class: this.getElementCssClass("cancelButton"),
              on: {
                click: this.cancel
              }
            }, this.cancelButtonText),
            ok: createElement("button", {
              attrs: {
                type: "button",
                "aria-label": this.okButtonAriaLabel
              },
              class: this.getElementCssClass("okButton"),
              on: {
                click: this.ok
              }
            }, this.okButtonText)
          };
          if (type === DialogType.Alert) {
            subElements.push(buttons.ok);
          } else if (type === DialogType.Confirm || type === DialogType.Prompt) {
            subElements.push(buttons.cancel);
            subElements.push(buttons.ok);
          }
          return createElement("div", {
            class: this.getElementCssClass("buttons")
          }, subElements);
        }
      });
      const TDialogOverlayWrapperTransitionDialog = Vue__default["default"].extend({
        name: "TDialogOverlayWrapperTransitionDialog",
        props: {
          getElementCssClass: {
            type: Function,
            required: true
          },
          dialogShow: {
            type: Boolean,
            required: true
          },
          titleTag: {
            type: String,
            required: true
          },
          title: {
            type: String,
            default: void 0
          },
          icon: {
            type: String,
            default: void 0
          },
          textTag: {
            type: String,
            required: true
          },
          text: {
            type: String,
            default: void 0
          },
          cancelButtonText: {
            type: String,
            required: true
          },
          cancelButtonAriaLabel: {
            type: String,
            default: void 0
          },
          okButtonText: {
            type: String,
            required: true
          },
          okButtonAriaLabel: {
            type: String,
            default: void 0
          },
          showCloseButton: {
            type: Boolean,
            required: true
          },
          preConfirm: {
            type: Function,
            default: void 0
          },
          inputAttributes: {
            type: Object,
            default: void 0
          },
          inputType: {
            type: String,
            required: true
          },
          inputValidator: {
            type: Function,
            default: void 0
          },
          inputValue: {
            type: [String, Array],
            default: void 0
          },
          inputOptions: {
            type: [Array, Object],
            default: void 0
          },
          inputPlaceholder: {
            type: String,
            default: void 0
          },
          type: {
            type: String,
            required: true
          }
        },
        data() {
          return {
            currentValue: null,
            errorMessage: "",
            busy: false
          };
        },
        methods: {
          submitHandler(e) {
            return this.resolveParam(this.inputValidator, this.currentValue).then((errorMessage) => {
              if (errorMessage && typeof errorMessage === "string") {
                this.errorMessage = String(errorMessage);
                return;
              }
              this.resolveParam(this.preConfirm, this.currentValue).then((response) => {
                this.$emit("submit", e, this.currentValue, response);
              }).catch((error) => {
                this.$emit("submit-error", e, this.currentValue, error);
              }).then(() => {
                this.busy = false;
              });
            }).catch((errorMessage) => {
              this.errorMessage = String(errorMessage);
            });
          },
          inputHandler(input) {
            this.errorMessage = "";
            this.currentValue = input;
          },
          resolveParam(resolvable, input) {
            if (typeof resolvable === "function") {
              const result = resolvable(input);
              if (result instanceof Promise) {
                this.busy = true;
                return result;
              }
              return new Promise((resolve) => {
                resolve(result);
              });
            }
            return new Promise((resolve) => resolve());
          }
        },
        render(createElement) {
          if (!this.dialogShow) {
            return createElement();
          }
          return createElement("div", {
            ref: "dialog",
            class: this.getElementCssClass("dialog")
          }, [
            createElement(TDialogOverlayWrapperTransitionDialogLoader, {
              props: {
                getElementCssClass: this.getElementCssClass,
                busy: this.busy
              },
              scopedSlots: {
                loader: this.$scopedSlots.loader
              }
            }),
            createElement(TDialogOverlayWrapperTransitionDialogClose, {
              props: {
                getElementCssClass: this.getElementCssClass,
                showCloseButton: this.showCloseButton
              },
              on: {
                dismiss: (e) => this.$emit("dismiss", e)
              },
              scopedSlots: {
                closeButton: this.$scopedSlots.closeButton
              }
            }),
            createElement("div", {
              ref: "body",
              class: this.getElementCssClass("body")
            }, [
              createElement(TDialogOverlayWrapperTransitionDialogIcon, {
                props: {
                  getElementCssClass: this.getElementCssClass,
                  icon: this.icon
                },
                scopedSlots: {
                  icon: this.$scopedSlots.icon
                }
              }),
              createElement(TDialogOverlayWrapperTransitionDialogContent, {
                props: {
                  getElementCssClass: this.getElementCssClass,
                  titleTag: this.titleTag,
                  title: this.title,
                  textTag: this.textTag,
                  text: this.text,
                  type: this.type,
                  inputAttributes: this.inputAttributes,
                  inputType: this.inputType,
                  inputValue: this.inputValue,
                  inputOptions: this.inputOptions,
                  inputPlaceholder: this.inputPlaceholder,
                  errorMessage: this.errorMessage
                },
                on: {
                  input: this.inputHandler
                },
                scopedSlots: {
                  title: this.$scopedSlots.title
                }
              }, this.$slots.default)
            ]),
            createElement(TDialogOverlayWrapperTransitionDialogButtons, {
              props: {
                getElementCssClass: this.getElementCssClass,
                type: this.type,
                cancelButtonText: this.cancelButtonText,
                cancelButtonAriaLabel: this.cancelButtonAriaLabel,
                okButtonText: this.okButtonText,
                okButtonAriaLabel: this.okButtonAriaLabel
              },
              on: {
                cancel: (e) => this.$emit("cancel", e),
                submit: this.submitHandler
              },
              scopedSlots: {
                buttons: this.$scopedSlots.buttons
              }
            })
          ]);
        }
      });
      const TDialogOverlayWrapperTransition = Vue__default["default"].extend({
        name: "TDialogOverlayWrapperTransition",
        props: {
          getElementCssClass: {
            type: Function,
            required: true
          },
          dialogShow: {
            type: Boolean,
            required: true
          },
          titleTag: {
            type: String,
            required: true
          },
          title: {
            type: String,
            default: void 0
          },
          icon: {
            type: String,
            default: void 0
          },
          textTag: {
            type: String,
            required: true
          },
          text: {
            type: String,
            default: void 0
          },
          cancelButtonText: {
            type: String,
            required: true
          },
          cancelButtonAriaLabel: {
            type: String,
            default: void 0
          },
          okButtonText: {
            type: String,
            required: true
          },
          okButtonAriaLabel: {
            type: String,
            default: void 0
          },
          showCloseButton: {
            type: Boolean,
            required: true
          },
          preConfirm: {
            type: Function,
            default: void 0
          },
          inputAttributes: {
            type: Object,
            default: void 0
          },
          inputType: {
            type: String,
            required: true
          },
          inputValidator: {
            type: Function,
            default: void 0
          },
          inputValue: {
            type: [String, Array],
            default: void 0
          },
          inputOptions: {
            type: [Array, Object],
            default: void 0
          },
          inputPlaceholder: {
            type: String,
            default: void 0
          },
          type: {
            type: String,
            required: true
          }
        },
        render(createElement) {
          return createElement("transition", {
            props: {
              enterClass: this.getElementCssClass("enterClass"),
              enterActiveClass: this.getElementCssClass("enterActiveClass"),
              enterToClass: this.getElementCssClass("enterToClass"),
              leaveClass: this.getElementCssClass("leaveClass"),
              leaveActiveClass: this.getElementCssClass("leaveActiveClass"),
              leaveToClass: this.getElementCssClass("leaveToClass")
            }
          }, [
            createElement(TDialogOverlayWrapperTransitionDialog, {
              props: {
                getElementCssClass: this.getElementCssClass,
                dialogShow: this.dialogShow,
                titleTag: this.titleTag,
                title: this.title,
                icon: this.icon,
                textTag: this.textTag,
                text: this.text,
                cancelButtonText: this.cancelButtonText,
                cancelButtonAriaLabel: this.cancelButtonAriaLabel,
                okButtonText: this.okButtonText,
                okButtonAriaLabel: this.okButtonAriaLabel,
                showCloseButton: this.showCloseButton,
                preConfirm: this.preConfirm,
                inputAttributes: this.inputAttributes,
                inputType: this.inputType,
                inputValidator: this.inputValidator,
                inputValue: this.inputValue,
                inputOptions: this.inputOptions,
                inputPlaceholder: this.inputPlaceholder,
                type: this.type
              },
              scopedSlots: this.$scopedSlots,
              on: {
                dismiss: (e) => this.$emit("dismiss", e),
                cancel: (e) => this.$emit("cancel", e),
                submit: (e, input, response) => this.$emit("submit", e, input, response),
                "submit-error": (e, input, error) => this.$emit("submit-error", e, input, error)
              }
            }, this.$slots.default)
          ]);
        }
      });
      const TDialogOverlayWrapper = Vue__default["default"].extend({
        name: "TDialogOverlayWrapper",
        props: {
          getElementCssClass: {
            type: Function,
            required: true
          },
          dialogShow: {
            type: Boolean,
            required: true
          },
          titleTag: {
            type: String,
            required: true
          },
          title: {
            type: String,
            default: void 0
          },
          icon: {
            type: String,
            default: void 0
          },
          textTag: {
            type: String,
            required: true
          },
          text: {
            type: String,
            default: void 0
          },
          cancelButtonText: {
            type: String,
            required: true
          },
          cancelButtonAriaLabel: {
            type: String,
            default: void 0
          },
          okButtonText: {
            type: String,
            required: true
          },
          okButtonAriaLabel: {
            type: String,
            default: void 0
          },
          showCloseButton: {
            type: Boolean,
            required: true
          },
          preConfirm: {
            type: Function,
            default: void 0
          },
          inputAttributes: {
            type: Object,
            default: void 0
          },
          inputType: {
            type: String,
            required: true
          },
          inputValidator: {
            type: Function,
            default: void 0
          },
          inputValue: {
            type: [String, Array],
            default: void 0
          },
          inputOptions: {
            type: [Array, Object],
            default: void 0
          },
          inputPlaceholder: {
            type: String,
            default: void 0
          },
          type: {
            type: String,
            required: true
          }
        },
        render(createElement) {
          return createElement("div", {
            ref: "wrapper",
            class: this.getElementCssClass("wrapper")
          }, [
            createElement(TDialogOverlayWrapperTransition, {
              props: {
                type: this.type,
                dialogShow: this.dialogShow,
                getElementCssClass: this.getElementCssClass,
                titleTag: this.titleTag,
                title: this.title,
                icon: this.icon,
                textTag: this.textTag,
                text: this.text,
                cancelButtonText: this.cancelButtonText,
                cancelButtonAriaLabel: this.cancelButtonAriaLabel,
                okButtonText: this.okButtonText,
                okButtonAriaLabel: this.okButtonAriaLabel,
                showCloseButton: this.showCloseButton,
                preConfirm: this.preConfirm,
                inputAttributes: this.inputAttributes,
                inputType: this.inputType,
                inputValidator: this.inputValidator,
                inputValue: this.inputValue,
                inputOptions: this.inputOptions,
                inputPlaceholder: this.inputPlaceholder
              },
              scopedSlots: this.$scopedSlots,
              on: {
                dismiss: (e) => this.$emit("dismiss", e),
                cancel: (e) => this.$emit("cancel", e),
                submit: (e, input, response) => this.$emit("submit", e, input, response),
                "submit-error": (e, input, error) => this.$emit("submit-error", e, input, error)
              }
            }, this.$slots.default)
          ]);
        }
      });
      const TDialogOverlay = Vue__default["default"].extend({
        name: "TDialogOverlay",
        props: {
          getElementCssClass: {
            type: Function,
            required: true
          },
          overlayShow: {
            type: Boolean,
            required: true
          },
          dialogShow: {
            type: Boolean,
            required: true
          },
          titleTag: {
            type: String,
            required: true
          },
          title: {
            type: String,
            default: void 0
          },
          textTag: {
            type: String,
            required: true
          },
          text: {
            type: String,
            default: void 0
          },
          icon: {
            type: String,
            default: void 0
          },
          cancelButtonText: {
            type: String,
            required: true
          },
          cancelButtonAriaLabel: {
            type: String,
            default: void 0
          },
          okButtonText: {
            type: String,
            required: true
          },
          okButtonAriaLabel: {
            type: String,
            default: void 0
          },
          showCloseButton: {
            type: Boolean,
            required: true
          },
          preConfirm: {
            type: Function,
            default: void 0
          },
          inputAttributes: {
            type: Object,
            default: void 0
          },
          inputType: {
            type: String,
            required: true
          },
          inputValidator: {
            type: Function,
            default: void 0
          },
          inputValue: {
            type: [String, Array],
            default: void 0
          },
          inputOptions: {
            type: [Array, Object],
            default: void 0
          },
          inputPlaceholder: {
            type: String,
            default: void 0
          },
          type: {
            type: String,
            default: null
          }
        },
        methods: {
          clickHandler(e) {
            if (e.target !== this.$el) {
              return;
            }
            this.$emit("outside-click", e);
          },
          keyupHandler(e) {
            this.$emit("keyup", e);
          },
          focus() {
            const overlay = this.$el;
            if (overlay && overlay.focus) {
              overlay.focus();
            }
          },
          enableBodyScroll() {
            const mdl = this.$el;
            bodyScrollLock.enableBodyScroll(mdl);
          },
          disableBodyScroll() {
            const mdl = this.$el;
            bodyScrollLock.disableBodyScroll(mdl, {
              reserveScrollBarGap: true
            });
          }
        },
        render(createElement) {
          if (!this.overlayShow) {
            return createElement();
          }
          return createElement("div", {
            attrs: {
              tabindex: 0
            },
            class: this.getElementCssClass("overlay"),
            on: {
              keyup: this.keyupHandler,
              click: this.clickHandler
            }
          }, [
            createElement(TDialogOverlayWrapper, {
              props: {
                type: this.type,
                getElementCssClass: this.getElementCssClass,
                dialogShow: this.dialogShow,
                titleTag: this.titleTag,
                title: this.title,
                icon: this.icon,
                textTag: this.textTag,
                text: this.text,
                cancelButtonText: this.cancelButtonText,
                cancelButtonAriaLabel: this.cancelButtonAriaLabel,
                okButtonText: this.okButtonText,
                okButtonAriaLabel: this.okButtonAriaLabel,
                showCloseButton: this.showCloseButton,
                preConfirm: this.preConfirm,
                inputAttributes: this.inputAttributes,
                inputType: this.inputType,
                inputValidator: this.inputValidator,
                inputValue: this.inputValue,
                inputOptions: this.inputOptions,
                inputPlaceholder: this.inputPlaceholder
              },
              scopedSlots: this.$scopedSlots,
              on: {
                dismiss: (e) => this.$emit("dismiss", e),
                cancel: (e) => this.$emit("cancel", e),
                submit: (e, input, response) => this.$emit("submit", e, input, response),
                "submit-error": (e, input, error) => this.$emit("submit-error", e, input, error)
              }
            }, this.$slots.default)
          ]);
        }
      });
      const getInitialData = (vm) => ({
        overlayShow: vm.value,
        dialogShow: vm.value,
        params: void 0,
        preventAction: false,
        hideReason: void 0,
        input: void 0,
        resolve: null,
        reject: null,
        preConfirmResponse: void 0,
        preConfirmError: void 0
      });
      const TDialog = Component.extend({
        name: "TDialog",
        props: {
          value: {
            type: Boolean,
            default: false
          },
          name: {
            type: String,
            default: void 0
          },
          titleTag: {
            type: String,
            default: "h3"
          },
          title: {
            type: String,
            default: void 0
          },
          icon: {
            type: String,
            default: void 0
          },
          textTag: {
            type: String,
            default: "p"
          },
          text: {
            type: String,
            default: void 0
          },
          clickToClose: {
            type: Boolean,
            default: true
          },
          escToClose: {
            type: Boolean,
            default: true
          },
          cancelButtonText: {
            type: String,
            default: "Cancel"
          },
          cancelButtonAriaLabel: {
            type: String,
            default: void 0
          },
          okButtonText: {
            type: String,
            default: "OK"
          },
          okButtonAriaLabel: {
            type: String,
            default: void 0
          },
          showCloseButton: {
            type: Boolean,
            default: false
          },
          disableBodyScroll: {
            type: Boolean,
            default: true
          },
          focusOnOpen: {
            type: Boolean,
            default: true
          },
          preConfirm: {
            type: Function,
            default: void 0
          },
          inputAttributes: {
            type: Object,
            default: void 0
          },
          inputType: {
            type: String,
            default: "text"
          },
          inputValidator: {
            type: Function,
            default: void 0
          },
          inputValue: {
            type: [String, Array],
            default: void 0
          },
          inputOptions: {
            type: [Array, Object],
            default: void 0
          },
          inputPlaceholder: {
            type: String,
            default: void 0
          },
          type: {
            type: String,
            default: DialogType.Alert
          },
          fixedClasses: {
            type: Object,
            default() {
              return {
                overlay: "overflow-auto scrolling-touch left-0 top-0 bottom-0 right-0 w-full h-full fixed",
                wrapper: "relative mx-auto",
                modal: "overflow-visible relative ",
                close: "flex items-center justify-center",
                dialog: "overflow-visible relative"
              };
            }
          },
          classes: {
            type: Object,
            default() {
              return {
                close: "bg-gray-100 text-gray-600 rounded-full absolute right-0 top-0 -m-3 h-8 w-8 transition duration-100 ease-in-out hover:bg-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50",
                closeIcon: "fill-current h-4 w-4",
                overlay: "z-40 bg-black bg-opacity-50",
                wrapper: "z-50 max-w-lg px-3 py-12",
                dialog: "bg-white shadow rounded text-left",
                body: "p-3 space-y-3",
                buttons: "p-3 flex space-x-4 justify-center bg-gray-100 rounded-b",
                iconWrapper: "bg-gray-100 flex flex-shrink-0 h-12 items-center justify-center rounded-full w-12 mx-auto",
                icon: "w-6 h-6 text-gray-500",
                content: "w-full flex justify-center flex-col",
                titleWrapper: "",
                title: "text-lg font-semibold text-center",
                textWrapper: "text-left w-full",
                text: "",
                cancelButton: "block px-4 py-2 transition duration-100 ease-in-out bg-white border border-gray-300 rounded shadow-sm hover:bg-gray-100 focus:border-gray-100 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed w-full max-w-xs",
                okButton: "block px-4 py-2 text-white transition duration-100 ease-in-out bg-blue-500 border border-transparent rounded shadow-sm hover:bg-blue-600 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed w-full max-w-xs",
                inputWrapper: "mt-3 flex items-center space-x-3",
                input: "block w-full px-3 py-2 text-black placeholder-gray-400 transition duration-100 ease-in-out bg-white border border-gray-300 rounded shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed w-full",
                select: "block w-full px-3 py-2 text-black placeholder-gray-400 transition duration-100 ease-in-out bg-white border border-gray-300 rounded shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50  disabled:opacity-50 disabled:cursor-not-allowed w-full",
                radioWrapper: "flex items-center space-x-2",
                radio: "text-blue-500 transition duration-100 ease-in-out border-gray-300 shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 focus:ring-offset-0  disabled:opacity-50 disabled:cursor-not-allowed",
                radioText: "",
                checkboxWrapper: "flex items-center space-x-2",
                checkbox: "text-blue-500 transition duration-100 ease-in-out border-gray-300 rounded shadow-sm focus:border-blue-500 focus:ring-2 focus:ring-blue-500 focus:outline-none focus:ring-opacity-50 focus:ring-offset-0  disabled:opacity-50 disabled:cursor-not-allowed",
                checkboxText: "",
                errorMessage: "text-red-500 block text-sm",
                busyWrapper: "absolute bg-opacity-50 bg-white flex h-full items-center justify-center left-0 top-0 w-full",
                busyIcon: "animate-spin h-6 w-6 fill-current text-gray-500",
                overlayEnterClass: "opacity-0",
                overlayEnterActiveClass: "transition ease-out duration-100",
                overlayEnterToClass: "opacity-100",
                overlayLeaveClass: "opacity-100",
                overlayLeaveActiveClass: "transition ease-in duration-75",
                overlayLeaveToClass: "opacity-0",
                enterClass: "",
                enterActiveClass: "",
                enterToClass: "",
                leaveClass: "",
                leaveActiveClass: "",
                leaveToClass: ""
              };
            }
          }
        },
        data() {
          return getInitialData(this);
        },
        watch: {
          value(value) {
            if (value) {
              this.show();
            } else {
              this.hideReason = HideReason.Value;
              this.close();
            }
          },
          overlayShow(shown) {
            return __awaiter(this, void 0, void 0, function* () {
              if (shown) {
                this.$emit("input", shown);
                this.$emit("change", shown);
                yield this.$nextTick();
                this.dialogShow = true;
              } else {
                this.closed();
              }
            });
          },
          dialogShow(shown) {
            return __awaiter(this, void 0, void 0, function* () {
              if (!shown) {
                this.$emit("input", shown);
                this.$emit("change", shown);
                yield this.$nextTick();
                this.overlayShow = false;
              } else {
                this.opened();
              }
            });
          }
        },
        beforeDestroy() {
          const overlay = this.getOverlay();
          if (this.disableBodyScroll && overlay) {
            overlay.focus();
            overlay.enableBodyScroll();
          }
        },
        created() {
          if (this.name) {
            this.$dialog.$on(`show-${this.name}`, (resolve, reject, params = void 0) => {
              this.resolve = resolve;
              this.reject = reject;
              this.show(params);
            });
            this.$dialog.$on(`hide-${this.name}`, () => {
              this.hideReason = HideReason.Method;
              this.close();
            });
          }
        },
        render(createElement) {
          return createElement("transition", {
            props: {
              enterClass: this.getElementCssClass("overlayEnterClass"),
              enterActiveClass: this.getElementCssClass("overlayEnterActiveClass"),
              enterToClass: this.getElementCssClass("overlayEnterToClass"),
              leaveClass: this.getElementCssClass("overlayLeaveClass"),
              leaveActiveClass: this.getElementCssClass("overlayLeaveActiveClass"),
              leaveToClass: this.getElementCssClass("overlayLeaveToClass")
            }
          }, [
            createElement(TDialogOverlay, {
              ref: "overlay",
              props: {
                type: this.type,
                overlayShow: this.overlayShow,
                dialogShow: this.dialogShow,
                titleTag: this.titleTag,
                title: this.title,
                icon: this.icon,
                textTag: this.textTag,
                text: this.text,
                cancelButtonText: this.cancelButtonText,
                cancelButtonAriaLabel: this.cancelButtonAriaLabel,
                okButtonText: this.okButtonText,
                okButtonAriaLabel: this.okButtonAriaLabel,
                showCloseButton: this.showCloseButton,
                preConfirm: this.preConfirm,
                inputAttributes: this.inputAttributes,
                inputType: this.inputType,
                inputValidator: this.inputValidator,
                inputValue: this.inputValue,
                inputOptions: this.inputOptions,
                inputPlaceholder: this.inputPlaceholder,
                getElementCssClass: this.getElementCssClass
              },
              scopedSlots: this.$scopedSlots,
              on: {
                "outside-click": this.outsideClick,
                keyup: this.keyupHandler,
                dismiss: (e) => this.dismiss(e),
                cancel: (e) => this.cancel(e),
                submit: (e, input, response) => this.submit(e, input, response),
                "submit-error": (e, input, error) => this.submitError(e, input, error)
              }
            }, this.$slots.default)
          ]);
        },
        methods: {
          getOverlay() {
            return this.$refs.overlay;
          },
          keyupHandler(e) {
            if (e.keyCode === Key$1.ESC && this.escToClose) {
              this.esc(e);
            }
          },
          beforeOpen() {
            this.$emit("before-open", { params: this.params, cancel: this.closeCancel });
          },
          opened() {
            this.$emit("opened", { params: this.params });
            this.prepareDomForDialog();
          },
          beforeClose(event) {
            if (this.disableBodyScroll) {
              const overlay = this.getOverlay();
              if (overlay) {
                overlay.focus();
                overlay.enableBodyScroll();
              }
            }
            const beforeCloseParams = {
              cancel: this.closeCancel,
              event,
              reason: this.hideReason
            };
            if (this.input !== void 0) {
              beforeCloseParams.input = this.input;
            }
            if (this.preConfirmResponse !== void 0) {
              beforeCloseParams.response = this.preConfirmResponse;
            }
            this.$emit("before-close", beforeCloseParams);
          },
          closed() {
            const response = {
              hideReason: this.hideReason,
              isOk: this.hideReason === HideReason.Ok,
              isCancel: this.hideReason === HideReason.Cancel,
              isDismissed: typeof this.hideReason === "string" && [HideReason.Close, HideReason.Esc, HideReason.Outside].includes(this.hideReason)
            };
            if (this.type === DialogType.Prompt && this.hideReason === HideReason.Ok && this.input !== void 0) {
              response.input = this.input;
            }
            if (this.preConfirmResponse !== void 0) {
              response.response = this.preConfirmResponse;
            } else if (this.preConfirmError !== void 0) {
              response.response = this.preConfirmError;
            }
            this.$emit("closed", response);
            if (this.reject && this.preConfirmError !== void 0) {
              this.reject(this.preConfirmError);
            } else if (this.resolve) {
              this.resolve(response);
            }
            this.reset();
          },
          prepareDomForDialog() {
            const overlay = this.getOverlay();
            if (!overlay) {
              return;
            }
            if (this.disableBodyScroll) {
              overlay.disableBodyScroll();
            }
            if (this.focusOnOpen) {
              overlay.focus();
            }
          },
          dismiss(e) {
            this.hideReason = HideReason.Close;
            this.close(e);
          },
          esc(e) {
            this.hideReason = HideReason.Esc;
            this.close(e);
          },
          cancel(e) {
            this.hideReason = HideReason.Cancel;
            this.close(e);
          },
          hide(e) {
            this.hideReason = HideReason.Method;
            this.close(e);
          },
          submit(e, input, response) {
            this.hideReason = HideReason.Ok;
            this.input = input;
            this.preConfirmResponse = response;
            this.close(e);
          },
          submitError(e, input, error) {
            this.hideReason = HideReason.Ok;
            this.input = input;
            this.preConfirmError = error;
            this.close(e);
          },
          close(e) {
            this.beforeClose(e);
            if (!this.preventAction) {
              this.dialogShow = false;
            } else {
              this.preventAction = false;
            }
          },
          show(params = void 0) {
            this.params = params;
            this.beforeOpen();
            if (!this.preventAction) {
              this.overlayShow = true;
            } else {
              this.preventAction = false;
            }
          },
          closeCancel() {
            this.preventAction = true;
          },
          reset() {
            Object.assign(this.$data, getInitialData(this));
          },
          outsideClick(e) {
            if (this.clickToClose) {
              this.hideReason = HideReason.Outside;
              this.close(e);
            }
          }
        }
      });
      exports2.TAlert = TAlert;
      exports2.TButton = TButton;
      exports2.TCard = TCard;
      exports2.TCheckbox = TCheckbox;
      exports2.TCheckboxGroup = TCheckboxGroup;
      exports2.TDatepicker = TDatepicker;
      exports2.TDialog = TDialog;
      exports2.TDropdown = TDropdown;
      exports2.TInput = TInput;
      exports2.TInputGroup = TInputGroup;
      exports2.TModal = TModal;
      exports2.TPagination = TPagination;
      exports2.TRadio = TRadio;
      exports2.TRadioGroup = TRadioGroup;
      exports2.TRichSelect = TRichSelect;
      exports2.TSelect = TSelect;
      exports2.TTable = TTable;
      exports2.TTag = TTag;
      exports2.TTextarea = TTextarea;
      exports2.TToggle = TToggle;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// dep:vue-tailwind_dist_components
var vue_tailwind_dist_components_default = require_components();
export {
  vue_tailwind_dist_components_default as default
};
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
//# sourceMappingURL=vue-tailwind_dist_components.js.map
